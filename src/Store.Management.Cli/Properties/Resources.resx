<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="OptionHelp" xml:space="preserve">
    <value>Show the built-in help text.</value>
  </data>
  <data name="OptionVersion" xml:space="preserve">
    <value>Display version information.</value>
  </data>
  <data name="UsageAdd" xml:space="preserve">
    <value>0store add DIGEST (DIRECTORY | (ARCHIVE [EXTRACT]))</value>
  </data>
  <data name="UsageAudit" xml:space="preserve">
    <value>0store audit [CACHE+]</value>
  </data>
  <data name="UsageCopy" xml:space="preserve">
    <value>0store copy DIRECTORY [CACHE]</value>
  </data>
  <data name="UsageFind" xml:space="preserve">
    <value>0store find DIGEST</value>
  </data>
  <data name="UsageList" xml:space="preserve">
    <value>0store list</value>
  </data>
  <data name="UsageManifest" xml:space="preserve">
    <value>0store manifest DIRECTORY [ALGORITHM]</value>
  </data>
  <data name="UsageOptimize" xml:space="preserve">
    <value>0store optimise [CACHE+]</value>
  </data>
  <data name="UsageRemove" xml:space="preserve">
    <value>0store remove DIGEST+</value>
  </data>
  <data name="UsageVerify" xml:space="preserve">
    <value>0store verify (DIGEST|DIRECTORY)+</value>
  </data>
  <data name="WrongNoArguments" xml:space="preserve">
    <value>Wrong number of arguments.
Usage: {0}</value>
  </data>
  <data name="Options" xml:space="preserve">
    <value>Options:</value>
  </data>
  <data name="UnknownMode" xml:space="preserve">
    <value>Unknown operation mode.
Try 0store --help</value>
  </data>
  <data name="NoAuditSupport" xml:space="preserve">
    <value>This store does not support auditing.</value>
  </data>
  <data name="StoreEntryOK" xml:space="preserve">
    <value>The store entry is OK.</value>
  </data>
  <data name="DirectoryNotFound" xml:space="preserve">
    <value>The director '{0}' was not found.</value>
  </data>
  <data name="NoSuchFileOrDirectory" xml:space="preserve">
    <value>No such file or directory: {0}</value>
  </data>
  <data name="DetailsAdd" xml:space="preserve">
    <value>To add a directory to the store (makes a copy):
0store add sha256=XXX directory

To add an archive to the store:
0store add sha256=XXX archive.tgz

To add a subdirectory of an archive to the store:
0store add sha256=XXX archive.tgz subdir

The actual digest is calculated and compared to the given one. If they don't match, the operation is rejected.</value>
  </data>
  <data name="DetailsAudit" xml:space="preserve">
    <value>Verifies  every  implementation in each of the given cache directories, or in all of the default cache directories if no arguments are given. This will detect any packages which have been tampered with since they were unpacked. If 0store itself could have been modified by an attacker, mount the suspect file-system on a known-good machine and run that machine's 0store on the mounted cache directory.
See the "verify" command for details of the verification performed on each package.</value>
  </data>
  <data name="DetailsCopy" xml:space="preserve">
    <value>To  copy an implementation (a directory with a name in the form "algorithm=value"), use the copy function. This is similar to performing a normal recursive directory copy followed by a 0store verify to check that the name matches the contents. E.g.:
0store copy ~someuser/.cache/0install.net/implementations/sha256=XXX /var/cache/0install.net/implementations/</value>
  </data>
  <data name="DetailsFind" xml:space="preserve">
    <value>To find the path of a stored item:
0store find sha256=XXX</value>
  </data>
  <data name="DetailsList" xml:space="preserve">
    <value>See the list of implementation caches currently configured:
0store list

To add directories to this list, add them to your 'implementation-dirs' configuration file.</value>
  </data>
  <data name="DetailsManage" xml:space="preserve">
    <value>To verify or remove feeds or implementations:
0store manage

Displays a GUI for managing implementations in the store. Associations with cached feeds are displayed.</value>
  </data>
  <data name="DetailsManifest" xml:space="preserve">
    <value>To generate the manifest for a directory structure:
0store manifest DIRECTORY [ALGORITHM]

The manifest lists every file and directory in the tree, along with the digest of each file, thus uniquely identifying that particular set of files. After the manifest, the last line gives the digest of the manifest itself.

This value is needed when creating feed files. However, the 0publish command will automatically calculate the required digest for you and add it to a feed file. See the packager's guide on the Zero Install web site for details.

Supported algorithms are 'sha1' (supported by all versions), 'sha1new' (requires injector 0.20 or later) and 'sha256'.</value>
  </data>
  <data name="DetailsOptimise" xml:space="preserve">
    <value>To hard-link duplicate files together to save space:
0store optimise [CACHE]

This reads in all the manifest files in the cache directory (~/.cache/0install.net/implementations by default) and looks for duplicates (files with the same permissions, modification time and digest). When it finds a pair, it deletes one and replaces it (atomically) with a hard-link to the other.

Implementations using the old 'sha1' algorithm are not optimised.</value>
  </data>
  <data name="DetailsRemove" xml:space="preserve">
    <value>To remove an item from the store:
0store remove sha256=XXX</value>
  </data>
  <data name="DetailsVerify" xml:space="preserve">
    <value>To check that an item is stored correctly:
0store verify /path/to/sha256=XXX

This calculates the manifest of the directory and checks that its digest matches the directory's name. It also checks that it matches the digest of the .manifest file inside the directory. If the .manifest doesn't correspond to the current tree, it displays a list of the differences (in unified diff format).</value>
  </data>
  <data name="Usage" xml:space="preserve">
    <value>Usage:</value>
  </data>
  <data name="OptionMan" xml:space="preserve">
    <value>Display more comprehensive documentation for the operation modes.</value>
  </data>
  <data name="AuditErrors" xml:space="preserve">
    <value>One or more problems were found in the store.</value>
  </data>
  <data name="AuditPass" xml:space="preserve">
    <value>No problems were found in the store.</value>
  </data>
  <data name="SuccessfullyRemoved" xml:space="preserve">
    <value>Successfully removed {0}.</value>
  </data>
</root>
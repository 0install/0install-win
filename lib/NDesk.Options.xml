<doc>
    <assembly>
        <name>NDesk.Options</name>
    </assembly>
    <members>
        <member name="T:NDesk.Options.Option">
            <summary>
      Represents information about an option.
    </summary>
            <remarks>
                <para>
        Instances of <see cref="T:NDesk.Options.Option" /> are created via
        the various <see cref="M:NDesk.Options.OptionSet.Add" /> overloads, 
        such as:
      </para>
                <list type="bullet">
                    <item>
                        <term>
                            <see cref="M:NDesk.Options.OptionSet.Add(System.String,System.Action{System.String})" />
                        </term>
                    </item>
                    <item>
                        <term>
                            <see cref="M:NDesk.Options.OptionSet.Add(System.String,System.String,System.Action{System.String})" />
                        </term>
                    </item>
                    <item>
                        <term>
                            <see cref="M:NDesk.Options.OptionSet.Add(System.String,NDesk.Options.OptionAction{System.String,System.String})" />
                        </term>
                    </item>
                    <item>
                        <term>
                            <see cref="M:NDesk.Options.OptionSet.Add(System.String,System.String,NDesk.Options.OptionAction{System.String,System.String})" />
                        </term>
                    </item>
                    <item>
                        <term>
                            <see cref="M:NDesk.Options.OptionSet.Add``1(System.String,System.Action{``0})" />
                        </term>
                    </item>
                    <item>
                        <term>
                            <see cref="M:NDesk.Options.OptionSet.Add``1(System.String,System.String,System.Action{``0})" />
                        </term>
                    </item>
                    <item>
                        <term>
                            <see cref="M:NDesk.Options.OptionSet.Add``2(System.String,NDesk.Options.OptionAction{``0,``1})" />
                        </term>
                    </item>
                    <item>
                        <term>
                            <see cref="M:NDesk.Options.OptionSet.Add``2(System.String,System.String,NDesk.Options.OptionAction{``0,``1})" />
                        </term>
                    </item>
                </list>
                <para>
        You can also add custom <see cref="T:NDesk.Options.Option" /> 
        subclasses to an <see cref="T:NDesk.Options.OptionSet" /> via the 
        <see cref="M:NDesk.Options.OptionSet.Add(NDesk.Options.Option)" />
        method.
      </para>
                <block subset="none" type="overrides">
        Inheritors of this type must override the <see langword="abstract" /> method
        <see cref="M:NDesk.Options.Option.OnParseComplete(NDesk.Options.OptionContext)" />,
        which is (indirectly) invoked from within 
        <see cref="M:NDesk.Options.OptionSet.Parse(System.String,NDesk.Options.OptionContext)" />
        when an option matching one of the <paramref name="prototype" />
        aliases is encountered.
      </block>
            </remarks>
        </member>
        <member name="C:NDesk.Options.Option(System.String,System.String)">
            <param name="prototype">
          A <see cref="T:System.String" /> containing a <c>|</c>-separated
          list of option names (aliases) and an optional value-type specifier.
        </param>
            <param name="description">
          A <see cref="T:System.String" /> containing documentation for the
          option.
        </param>
            <summary>
          Creates and initializes a new instance of the 
          <see cref="T:NDesk.Options.Option" /> class.
        </summary>
            <remarks>
                <para>
            This constructor initializes the 
            <see cref="P:NDesk.Options.Option.Prototype" /> property of the
            new instance using <paramref name="prototype" />, the 
            <see cref="P:NDesk.Options.Option.Description" /> property of the
            new instance using <paramref name="description" />. and
            initializes the <see cref="P:NDesk.Options.Option.MaxValueCount" /> 
            property of the new instance to <c>1</c>.
          </para>
                <para>
            This is equivalent to calling the 
            <see cref="C:NDesk.Options.Option(System.String,System.String,System.Int32)" />
            constructor as with <c>Option(<paramref name="prototype" />, 
            <paramref name="description" />, 1)</c>.
          </para>
            </remarks>
            <exception cref="T:System.ArgumentException">
                <para>
                    <paramref name="prototype" /> is the empty string <c>""</c>.
          </para>
                <para>-or-</para>
                <para>
                    <paramref name="prototype" /> contains an empty alias, such as
            <c>a||b</c>.
          </para>
                <para>-or-</para>
                <para>
            Conflicting <see cref="T:NDesk.Options.OptionValueType" /> values
            were found within <paramref name="prototype" />.
          </para>
                <para>-or-</para>
                <para>
                    <paramref name="prototype" /> only includes the default handler
            <c>&lt;&gt;</c> and <paramref name="prototype" /> did not specify an
            <see cref="T:NDesk.Options.OptionValueType" /> value of
            <see cref="F:NDesk.Options.OptionValueType.None" />.
          </para>
            </exception>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="prototype" /> is <see langword="null" />.
        </exception>
        </member>
        <member name="C:NDesk.Options.Option(System.String,System.String,System.Int32)">
            <param name="prototype">
          A <see cref="T:System.String" /> containing a <c>|</c>-separated
          list of option names (aliases) and an optional value-type specifier.
        </param>
            <param name="description">
          A <see cref="T:System.String" /> containing documentation for the
          option.
        </param>
            <param name="maxValueCount">
          A <see cref="T:System.Int32" /> containing the number of values this
          option accepts.
        </param>
            <summary>
          Creates and initializes a new instance of the 
          <see cref="T:NDesk.Options.Option" /> class.
        </summary>
            <remarks>
                <para>
            This constructor initializes the 
            <see cref="P:NDesk.Options.Option.Prototype" /> property of the
            new instance using <paramref name="prototype" />, the 
            <see cref="P:NDesk.Options.Option.Description" /> property of the
            new instance using <paramref name="description" />. and
            initializes the <see cref="P:NDesk.Options.Option.MaxValueCount" /> 
            property of the new instance using <paramref name="maxValueCount" />.
          </para>
                <para>
                    <paramref name="prototype" /> is a <c>|</c>-separated list of
            option names.  It should be listed in shortest-to-longest order,
            e.g. <c>h|help</c>.  <paramref name="prototype" /> may contain a
            <see cref="T:NDesk.Options.OptionValueType" /> specifier following
            one of the <c>|</c>-separated entries, and a value separator list
            following the <see cref="T:NDesk.Options.OptionValueType" /> 
            specifier.
          </para>
                <para>
            The <see cref="P:NDesk.Options.Option.OptionValueType" /> property
            is initialized based on whether a <c>=</c> or <c>:</c> follows one
            of the aliases within <paramref name="prototype" />.
            <c>=</c> specifies a 
            <see cref="F:NDesk.Options.OptionValueType.Required" /> value,
            while <c>:</c> specifies an 
            <see cref="F:NDesk.Options.OptionValueType.Optional" /> value.  
            If neither <c>=</c> nor <c>:</c> is not specified, then 
            <see cref="F:NDesk.Options.OptionValueType.None" /> is used.
            The value specifier may be used anywhere within 
            <paramref name="prototype" />, so <c>n|name=</c>, <c>n=|name</c> 
            and <c>n=|name=</c> are equivalent, but you cannot mix types; 
            <c>n:|name=</c> is invalid.
          </para>
                <para>
            A default handler may be specified by using <c>&lt;&gt;</c> as the
            option name.  The default handler is invoked for any unhandled
            argument within 
        		<see cref="M:NDesk.Options.OptionSet.Parse(System.Collections.Generic.IEnumerable{System.String})" />;
            consequently, if a default handler is provided then
        		<see cref="M:NDesk.Options.OptionSet.Parse(System.Collections.Generic.IEnumerable{System.String})" />
            will return an empty 
            <see cref="T:System.Collections.Generic.List{System.String}" />.
          </para>
                <para>
            The default handler may either be provided as a stand-alone 
            <see cref="T:NDesk.Options.Option" />, in which case it may not
            specify a <see cref="T:NDesk.Options.OptionValueType" /> other
            than <see cref="F:NDesk.Options.OptionValueType.None" />.
            Alternatively, it may be an alias, in which case the 
            <see cref="T:NDesk.Options.Option" /> must accept an
            <see cref="F:NDesk.Options.OptionValueType.Optional" /> or
            <see cref="F:NDesk.Options.OptionValueType.Required" /> value, and
            <paramref name="maxValueCount" /> must be <c>1</c>.
          </para>
                <para>
            Multiple values may be bundled together, such as 
            <c>-opt key=value</c>.  The value separator list specifies which
            characters can be used to split the value argument to generate
            separate values.  The value separator list is available when 
            <paramref name="maxValueCount" /> is greater than <c>1</c>, and
            and an <see cref="T:NDesk.Options.OptionValueType" /> was
            specified.  The value separator list follows the <c>=</c> or
            <c>:</c> and is one of the following:
          </para>
                <list type="bullet">
                    <item>
                        <term>
                            <para>
                A sequence of character enclosed by <c>{</c> and <c>}</c>.
                Multiple such sequences may be specified by listing the 
                <c>{...}</c> sequence multiple times.
              </para>
                            <para>
                The sequence <c>{}</c> requires that each value be a different 
                argument, and no argument splitting will be performed.
                This sequence has no effect if other separators are also
                listed (as separate arguments are always permitted for
                <see cref="F:NDesk.Options.OptionValueType.Required" />
                values).
              </para>
                        </term>
                    </item>
                    <item>
                        <term>
              Any literal character other than <c>{</c> and <c>}</c>.
            </term>
                    </item>
                </list>
                <para>
            If the separator list is not provided, then <c>=:</c> is the
            default separator list.
          </para>
                <para>
            For example, the prototype <c>"A:+-*/"</c> would permit any of
            `<c>+</c>', `<c>-</c>', `<c>*</c>', or `<c>/</c>' to be used to
            split an argument into values, so <c>-A:5/2</c> would generate the
            sequence of values <c>5</c> and <c>2</c> for the option <c>-A</c>.
            Furthermore, the prototype <c>"A={--&gt;}{=&gt;}"</c> would permit
            either the string <c>--&gt;</c> or the string <c>=&gt;</c> to be used,
            so <c>-A A-&gt;B C</c> woud parse <c>A-&gt;B</c> as one value and
            <c>C</c> as the other value, while <c>-A A--&gt;B C</c> would parse
            <c>A</c> as one value and <c>B</c> as the other value while
            <c>C</c> would be unhandled (unless the option required 3 values,
            in which case <c>C</c> would be the 3rd value).
          </para>
            </remarks>
            <exception cref="T:System.ArgumentException">
                <para>
                    <paramref name="prototype" /> is the empty string <c>""</c>.
          </para>
                <para>-or-</para>
                <para>
                    <paramref name="prototype" /> contains an empty alias, such as
            <c>a||b</c>.
          </para>
                <para>-or-</para>
                <para>
            Conflicting <see cref="T:NDesk.Options.OptionValueType" /> values
            were found within <paramref name="prototype" />.
          </para>
                <para>-or-</para>
                <para>
                    <paramref name="maxValueCount" /> is <c>0</c> and 
            <paramref name="prototype" /> specified an
            <see cref="T:NDesk.Options.OptionValueType" /> value of
            <see cref="F:NDesk.Options.OptionValueType.Optional" /> or
            <see cref="F:NDesk.Options.OptionValueType.Required" />.
          </para>
                <para>-or-</para>
                <para>
                    <paramref name="maxValueCount" /> is greater than <c>1</c> and
            <paramref name="prototype" /> specified an
            <see cref="T:NDesk.Options.OptionValueType" /> value of
            <see cref="F:NDesk.Options.OptionValueType.None" />.
          </para>
                <para>-or-</para>
                <para>
                    <paramref name="prototype" /> contains a separator list and
            <paramref name="maxValueCount" /> is <c>0</c> or <c>1</c>.
          </para>
                <para>-or-</para>
                <para>
                    <paramref name="prototype" /> contains a badly formatted 
            separator list, such as <c>{{</c>, <c>}}</c>, <c>{{}</c>, etc.
          </para>
                <para>-or-</para>
                <para>
                    <paramref name="prototype" /> only includes the default handler
            <c>&lt;&gt;</c> and <paramref name="prototype" /> did not specify an
            <see cref="T:NDesk.Options.OptionValueType" /> value of
            <see cref="F:NDesk.Options.OptionValueType.None" />.
          </para>
                <para>-or-</para>
                <para>
                    <paramref name="prototype" /> includes the default handler
            <c>&lt;&gt;</c>, and <paramref name="MaxValueCount" /> is greater
            than <c>1</c>.
          </para>
            </exception>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="prototype" /> is <see langword="null" />.
        </exception>
        </member>
        <member name="P:NDesk.Options.Option.Description">
            <summary>
          A <see cref="T:System.String" /> containing documentation for this
          option.
        </summary>
            <value>
          A <see cref="T:System.String" /> containing documentation for this
          option.
        </value>
            <remarks>
          This property is used to generate documentation within 
          <see cref="M:NDesk.Options.OptionSet.WriteOptionDescriptions(System.IO.TextWriter)" />.
          The string returned is translated via the 
          <paramref name="localizer" /> parameter provided to the
          <see cref="C:NDesk.Options.OptionSet(System.Converter{System.String,System.String})" />
          constructor before being written to the 
          <see cref="T:System.IO.TextWriter" /> instance.
        </remarks>
            <altmember cref="M:NDesk.Options.OptionSet.WriteOptionDescriptions(System.IO.TextWriter)" />
        </member>
        <member name="M:NDesk.Options.Option.GetNames">
            <summary>Retrieves all name aliases that make up 
          <see cref="P:NDesk.Options.Option.Prototype" />.</summary>
            <returns>
          A <see cref="T:System.String" /> array containing all name aliases
          for this <see cref="T:NDesk.Options.Option" /> instance.
        </returns>
            <remarks>
          The returned option names will not contain any 
          <see cref="T:NDesk.Options.OptionValueType" /> specifier that may be
          within <see cref="P:NDesk.Options.Option.Prototype" />.  
          If <see cref="P:NDesk.Options.Option.Prototype" /> is
          <c>a=|b=|c=</c>, the array returned will contain <c>a</c>, <c>b</c>,
          and <c>c</c>.
        </remarks>
        </member>
        <member name="M:NDesk.Options.Option.GetValueSeparators">
            <summary>
          Retreives all value separators, strings which are used to split an
          argument into one or more values for the this 
          <see cref="T:NDesk.Options.Option" />.
        </summary>
            <returns>
          A <see cref="T:System.String" /> array containing all strings that
          should be used when splitting an argument into one or more values
          for this <see cref="T:NDesk.Options.Option" />.
        </returns>
            <remarks>
                <para>
            Value separators may be provided within 
            <see cref="P:NDesk.Options.Option.Prototype" /> only if:
          </para>
                <list type="bullet">
                    <item>
                        <term>
                            <see cref="P:NDesk.Options.Option.MaxValueCount" /> is greater than 1.
            </term>
                    </item>
                    <item>
                        <term>
                            <see cref="P:NDesk.Options.Option.OptionValueType" /> is 
              <see cref="F:NDesk.Options.OptionValueType.Optional" /> or
              <see cref="F:NDesk.Options.OptionValueType.Required" />.
            </term>
                    </item>
                </list>
                <para>
            See the 
            <see cref="C:NDesk.Options.Option(System.String,System.String,System.Int32)" />
            constructor for more information.
          </para>
            </remarks>
        </member>
        <member name="M:NDesk.Options.Option.Invoke(NDesk.Options.OptionContext)">
            <param name="c">
          An <see cref="T:NDesk.Options.OptionContext" /> instance containing
          information about the option that was parsed.
        </param>
            <summary>
          Invokes 
          <see cref="M:NDesk.Options.Option.OnParseComplete(NDesk.Options.OptionContext)" />
          then clears out <paramref name="c" />.
        </summary>
            <remarks>
                <para>
            This method is invoked from within 
            <see cref="M:NDesk.Options.OptionSet.Parse(System.String,NDesk.Options.OptionContext)" />
            when an option with a name from
            <see cref="M:NDesk.Options.Option.GetNames" /> is encountered and
            matches the required number of values governed by
            <see cref="P:NDesk.Options.Option.OptionValueType" /> and
            <see cref="P:NDesk.Options.Option.MaxValueCount" />.
          </para>
                <block subset="none" type="behaviors">
                    <para>
              This method invokes 
              <see cref="M:NDesk.Options.Option.OnParseComplete(NDesk.Options.OptionContext)" />,
              passing along <paramref name="c" /> unchanged, and then sets the 
              <see cref="P:NDesk.Options.OptionContext.Option" /> and
              <see cref="P:NDesk.Options.OptionContext.OptionName" />
              properties to <see langword="null" />, and 
              <see cref="M:NDesk.Options.OptionValueCollection.Clear" />s out
              <see cref="P:NDesk.Options.OptionContext.OptionValues" />.
            </para>
                </block>
            </remarks>
            <altmember cref="M:NDesk.Options.Option.OnParseComplete(NDesk.Options.OptionContext)" />
            <altmember cref="M:NDesk.Options.OptionSet.Parse(System.String,NDesk.Options.OptionContext)" />
            <altmember cref="M:NDesk.Options.OptionSet.Parse(System.Collections.Generic.IEnumerable{System.String})" />
        </member>
        <member name="P:NDesk.Options.Option.MaxValueCount">
            <summary>
          A <see cref="T:System.Int32" /> containing the maximum number of
          values this <see cref="T:NDesk.Options.Option" /> accepts.
        </summary>
            <value>
          A <see cref="T:System.Int32" /> containing the maximum number of
          values this <see cref="T:NDesk.Options.Option" /> accepts.
        </value>
            <remarks>
                <para>
            This is a maximum, and may not be the number of values present
            within <see cref="P:NDesk.Options.OptionContext.OptionValues" />
            when 
            <see cref="M:NDesk.Options.Option.OnParseComplete(NDesk.Options.OptionContext)" />
            is invoked.  There will be 
            <see cref="P:NDesk.Options.Option.MaxValueCount" /> values if
            <see cref="P:NDesk.Options.Option.OptionValueType" /> is
            <see cref="F:NDesk.Options.OptionValueType.Required" />, but if
            <see cref="P:NDesk.Options.Option.OptionValueType" /> is
            <see cref="F:NDesk.Options.OptionValueType.Optional" /> then
            <see cref="P:NDesk.Options.OptionContext.OptionValues" /> may
            contain fewer items.
          </para>
            </remarks>
        </member>
        <member name="M:NDesk.Options.Option.OnParseComplete(NDesk.Options.OptionContext)">
            <param name="c">
          An <see cref="T:NDesk.Options.OptionContext" /> instance containing
          information about the option that was parsed.
        </param>
            <summary>
          Perform an action when an option is parsed.
        </summary>
            <remarks>
                <para>
            This method must be overridden by all subclasses, within which the
            subclass can perform some custom per-option processing.
          </para>
                <para>
            This method is invoked from within 
            <see cref="M:NDesk.Options.OptionSet.Parse(System.String,NDesk.Options.OptionContext)" />
            when an option with a name from
            <see cref="M:NDesk.Options.Option.GetNames" /> is encountered and
            matches the required number of values governed by
            <see cref="P:NDesk.Options.Option.OptionValueType" /> and
            <see cref="P:NDesk.Options.Option.MaxValueCount" />.
          </para>
            </remarks>
            <example>
                <para>
            The following example has a custom 
            <see cref="T:NDesk.Options.Option" /> subclass which overrides
            <see cref="M:NDesk.Options.Option.OnParseComplete(NDesk.Options.OptionContext)" />:
          </para>
                <code lang="C#" src="examples/subclass.cs">// Case-Insensitive and Concatenating OptionSet
using System;
using System.Collections.Generic;
using NDesk.Options;

class DemoOptionSet : OptionSet {
	protected override void InsertItem (int index, Option item)
	{
		if (item.Prototype.ToLower () != item.Prototype)
			throw new ArgumentException ("prototypes must be lower-case!");
		base.InsertItem (index, item);
	}

	protected override OptionContext CreateOptionContext ()
	{
		return new OptionContext (this);
	}

	protected override bool Parse (string option, OptionContext c)
	{
		string f, n, s, v;
		bool haveParts = GetOptionParts (option, out f, out n, out s, out v);
		Option nextOption = null;
		string newOption  = option;

		if (haveParts) {
			string nl = n.ToLower ();
			nextOption = Contains (nl) ? this [nl] : null;
			newOption = f + n.ToLower () + (v != null ? s + v : "");
		}

		if (c.Option != null) {
			// Prevent --a --b
			if (c.Option != null &amp;&amp; haveParts) {
				if (nextOption == null) {
					// ignore
				}
				else 
					throw new OptionException (
						string.Format ("Found option `{0}' as value for option `{1}'.",
							option, c.OptionName), c.OptionName);
			}

			// have a option w/ required value; try to concat values.
			if (AppendValue (option, c)) {
				if (!option.EndsWith ("\\") &amp;&amp; 
						c.Option.MaxValueCount == c.OptionValues.Count) {
					c.Option.Invoke (c);
				}
				return true;
			}
			else
				base.Parse (newOption, c);
		}

		if (!haveParts || v == null) {
			// Not an option; let base handle as a non-option argument.
			return base.Parse (newOption, c);
		}

		if (nextOption.OptionValueType != OptionValueType.None &amp;&amp; 
				v.EndsWith ("\\")) {
			c.Option = nextOption;
			c.OptionValues.Add (v);
			c.OptionName = f + n;
			return true;
		}

		return base.Parse (newOption, c);
	}

	private bool AppendValue (string value, OptionContext c)
	{
		bool added = false;
		string[] seps = c.Option.GetValueSeparators ();
		foreach (var o in seps.Length != 0
				? value.Split (seps, StringSplitOptions.None)
				: new string[]{value}) {
			int idx = c.OptionValues.Count-1;
			if (idx == -1 || !c.OptionValues [idx].EndsWith ("\\")) {
				c.OptionValues.Add (o);
				added = true;
			}
			else {
				c.OptionValues [idx] += value;
				added = true;
			}
		}
		return added;
	}
}

class Demo {
	public static void Main (string[] args)
	{
		List&lt;string&gt; names = new List&lt;string&gt; ();
		Dictionary&lt;string,string&gt; map = new Dictionary&lt;string,string&gt; ();
		int repeat = 1;

		OptionSet p = new DemoOptionSet () {
			{ "n|name=",    v =&gt; names.Add (v) },
			{ "r|repeat:",  (int v) =&gt; repeat = v },
			{ "m|map=",     (k,v) =&gt; map.Add (k, v) },
		};

		List&lt;string&gt; extra;
		try {
			extra = p.Parse (args);
		}
		catch (OptionException e) {
			Console.Write ("subclass: ");
			Console.WriteLine (e.Message);
			return;
		}

		string message;
		if (extra.Count &gt; 0) {
			message = string.Join (" ", extra.ToArray ());
		}
		else {
			message = "Hello {0}!";
		}

		foreach (string name in names) {
			for (int i = 0; i &lt; repeat; ++i)
				Console.WriteLine (message, name);
		}
		List&lt;string&gt; keys = new List&lt;string&gt;(map.Keys);
		keys.Sort ();
		foreach (string key in keys) {
			Console.WriteLine ("Key: {0}={1}", key, map [key]);
		}
	}
}

</code>
                <para>
            See <see cref="T:NDesk.Options.OptionSet" /> for more on this
            example.
          </para>
            </example>
            <altmember cref="M:NDesk.Options.Option.Invoke(NDesk.Options.OptionContext)" />
        </member>
        <member name="P:NDesk.Options.Option.OptionValueType">
            <summary>
          An <see cref="T:NDesk.Options.OptionValueType" /> instance
          specifying whether this <see cref="T:NDesk.Options.Option" /> takes
          a value, and if so, whether it's required or optional.
        </summary>
            <value>
          An <see cref="T:NDesk.Options.OptionValueType" /> specifying whether
          a value is required for this value.
        </value>
            <remarks>
                <para>
            This is initialized based on the presence of <c>=</c> or
            <c>:</c> within <see cref="P:NDesk.Options.Option.Prototype" />.
          </para>
            </remarks>
        </member>
        <member name="M:NDesk.Options.Option.Parse``1(System.String,NDesk.Options.OptionContext)">
            <typeparam name="T">
          The type to convert the string <paramref name="value" /> to.
        </typeparam>
            <param name="value">
          A <see cref="T:System.String" /> containing a representation of the
          type <typeparamref name="T" /> that should be converted into an
          instance of type <typeparamref name="T" />.
        </param>
            <param name="c">
          A <see cref="T:NDesk.Options.OptionContext" /> containing additional
          contextual information needed error handling.
        </param>
            <summary>
          Converts the <see cref="T:System.String" /><paramref name="value" />
          into an object of type <typeparamref name="T" />.
        </summary>
            <returns>
          If <paramref name="value" /> is <see langword="null" />, then 
          <see langword="default(T)" /> is returned.  Otherwise, 
          <paramref name="value" /> is converted to a value of type 
          <typeparamref name="T" />.
        </returns>
            <remarks>
                <para>
                    <see cref="M:System.ComponentModel.TypeDescriptor.GetConverter" />
            is used to get the 
            <see cref="T:System.ComponentModel.TypeConverter" /> associated
            with type <typeparamref name="T" />, and 
            <see cref="M:System.ComponentModel.TypeConverter.ConvertFromString" />
            is used to convert <paramref name="value" /> into a
            <typeparamref name="T" />.
          </para>
            </remarks>
            <exception cref="T:NDesk.Options.OptionException">
          If <paramref name="value" /> is not <see langword="null" /> and
          <see cref="M:System.ComponentModel.TypeConverter.ConvertFromString" />
          generated an exception while trying to convert 
          <paramref name="value" />.
        </exception>
        </member>
        <member name="P:NDesk.Options.Option.Prototype">
            <summary>
          The <see cref="T:NDesk.Options.Option" /> prototype, containing
          option name aliases and the option value requirements.
        </summary>
            <value>
          A <see cref="T:System.String" /> containing the prototype of this
          <see cref="T:NDesk.Options.Option" /> instance.
        </value>
            <remarks>
                <para>
            The prototype contains a <c>|</c>-separated list of all option name
            aliases and a value specifier of <c>=</c> for required values and
            <c>:</c> for optional values; if neither <c>=</c> nor <c>:</c> is
            present, no value is taken.
          </para>
                <para>
            If a value specifier is present, then a value separator list may
            also be present after the value specifier.
          </para>
            </remarks>
        </member>
        <member name="M:NDesk.Options.Option.ToString">
            <summary>
          Returns <see cref="P:NDesk.Options.Option.Prototype" />.
        </summary>
            <returns>
          A <see cref="T:System.String" /> containing
          <see cref="P:NDesk.Options.Option.Prototype" />.
        </returns>
            <remarks />
        </member>
        <member name="T:NDesk.Options.OptionAction`2">
            <typeparam name="TKey">The first parameter type.</typeparam>
            <typeparam name="TValue">The second parameter type.</typeparam>
            <param name="key">A value of type <typeparamref name="TKey" />.</param>
            <param name="value">A value of type <typeparamref name="TValue" />.</param>
            <summary>
      A delegate that can refer to any method taking two arguments and
      returning <see cref="T:System.Void" />.
    </summary>
            <remarks>
                <para>
        Use this to support <see cref="T:NDesk.Options.Option" />s 
        accepting two values registered with:
      </para>
                <list type="bullet">
                    <item>
                        <term>
                            <see cref="M:NDesk.Options.OptionSet.Add(System.String,NDesk.Options.OptionAction{System.String,System.String})" />
                        </term>
                    </item>
                    <item>
                        <term>
                            <see cref="M:NDesk.Options.OptionSet.Add(System.String,System.String,NDesk.Options.OptionAction{System.String,System.String})" />
                        </term>
                    </item>
                    <item>
                        <term>
                            <see cref="M:NDesk.Options.OptionSet.Add``2(System.String,NDesk.Options.OptionAction{``0,``1})" />
                        </term>
                    </item>
                    <item>
                        <term>
                            <see cref="M:NDesk.Options.OptionSet.Add``2(System.String,System.String,NDesk.Options.OptionAction{``0,``1})" />
                        </term>
                    </item>
                </list>
            </remarks>
        </member>
        <member name="T:NDesk.Options.OptionContext">
            <summary>Provides additional context information about the current 
      <see cref="T:NDesk.Options.Option" /> which is being parsed.</summary>
            <remarks>
      An instance of this class is provided via the registered callback when you
      override the 
      <see cref="M:NDesk.Options.Option.OnParseComplete(NDesk.Options.OptionContext)" />
      method.
    </remarks>
        </member>
        <member name="C:NDesk.Options.OptionContext(NDesk.Options.OptionSet)">
            <param name="set">
          The <see cref="T:NDesk.Options.OptionSet" /> instance to use for
          message localization purposes.
        </param>
            <summary>Constructs and initializes a new instance of the
          <see cref="T:NDesk.Options.OptionContext" /> class.</summary>
            <remarks>
          This constructor initializes the 
          <see cref="P:NDesk.Options.OptionContext.OptionSet" /> property of
          the new instance using <paramref name="set" />.
        </remarks>
        </member>
        <member name="P:NDesk.Options.OptionContext.Option">
            <summary>The <see cref="T:NDesk.Options.Option" /> being parsed.</summary>
            <value>The <see cref="T:NDesk.Options.Option" /> being parsed.</value>
            <remarks />
        </member>
        <member name="P:NDesk.Options.OptionContext.OptionIndex">
            <summary>
          The index within the options list of the last value within 
          <see cref="P:NDesk.Options.OptionContext.OptionValues" />.
        </summary>
            <value>
          A <see cref="T:System.Int32" /> containing the index within the
          options list of the last value within 
          <see cref="P:NDesk.Options.OptionContext.OptionValues" />.
        </value>
            <remarks />
            <altmember cref="M:NDesk.Options.OptionSet.Parse(System.Collections.Generic.IEnumerable&lt;System.String&gt;)" />
        </member>
        <member name="P:NDesk.Options.OptionContext.OptionName">
            <summary>The actual option name used.</summary>
            <value>A <see cref="T:System.String" /> containing the actual option name used.</value>
            <remarks>
          A <see cref="P:NDesk.Options.Option.Prototype" /> can contain multiple
          <c>|</c>-delimited aliases, e.g. <c>h|help</c>.  This property
          contains the actual option name specified, e.g. <c>-h</c> vs.
          <c>--help</c>.
        </remarks>
        </member>
        <member name="P:NDesk.Options.OptionContext.OptionSet">
            <summary>
          The <see cref="T:NDesk.Options.OptionSet" /> to use for message
          localizations.
        </summary>
            <value>
          The <see cref="T:NDesk.Options.OptionSet" /> to use for message
          localizations.
        </value>
            <remarks>
                <para>
            This property is initialized in the 
            <see cref="C:NDesk.Options.OptionContext(NDesk.Options.OptionSet)" />
            constructor.
          </para>
            </remarks>
        </member>
        <member name="P:NDesk.Options.OptionContext.OptionValues">
            <summary>
          A collection of <see cref="T:System.String" /> values to provide to
          <see cref="P:NDesk.Options.OptionContext.Option" />.
        </summary>
            <value>
          A <see cref="T:NDesk.Options.OptionValueCollection" /> containing 
          <see cref="T:System.String" /> values to provide to
          <see cref="P:NDesk.Options.OptionContext.Option" />.
        </value>
            <remarks>
                <para>
            The <see cref="T:NDesk.Options.OptionValueCollection" /> indexer
            makes use of the 
            <see cref="P:NDesk.Options.Option.OptionValueType" />
            and <see cref="P:NDesk.Options.Option.MaxValueCount" /> properties.
            If the index does not have a value, the index is less than
            <see cref="P:NDesk.Options.Option.MaxValueCount" />, and the 
            <see cref="P:NDesk.Options.OptionContext.Option" /> has a value
            type of <see cref="F:NDesk.Options.OptionValueType.Optional" />,
            <see langword="null" /> is returned; otherwise an
            <see cref="T:NDesk.Options.OptionException" /> is thrown.
          </para>
            </remarks>
        </member>
        <member name="T:NDesk.Options.OptionException">
            <summary>Represents the error that occurs when there is an error parsing
      an <see cref="T:NDesk.Options.Option" />.</summary>
            <remarks>
                <para>Instances of this class are thrown when:</para>
                <list type="bullet">
                    <item>
                        <term>There is an exception generated converting a string to an
        object of type <typeparamref name="T" /> within the callback
        registered by
        <see cref="M:NDesk.Options.OptionSet.Add``1(System.String,System.String,System.Action{``0})" />
        (and related overloads).
        </term>
                    </item>
                    <item>
                        <term>
                            <see cref="M:NDesk.Options.Option.Parse``1(System.String,NDesk.Options.OptionContext)" />
          could not convert a <see cref="T:System.String" /> to an object
          of type <typeparamref name="T" />.
        </term>
                    </item>
                    <item>
                        <term>
          An option with a <see cref="P:NDesk.Options.Option.OptionValueType" /> 
          value of <see cref="F:NDesk.Options.OptionValueType.Required" /> 
          does not have a value (usually because the start of the option was
          the last argument).
        </term>
                    </item>
                </list>
            </remarks>
        </member>
        <member name="C:NDesk.Options.OptionException(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <param name="info">
          The <see cref="T:System.Runtime.Serialization.SerializationInfo" />
          that holds the serialized object data about the exception being
          thrown.
        </param>
            <param name="context">
          The <see cref="T:System.Runtime.Serialization.StreamingContext" />
          that contains contextual information about the source or
          destination.
        </param>
            <summary>
          Initializes a new instance of the 
          <see cref="T:NDesk.Options.OptionException" /> class with serialized
          data.
        </summary>
            <remarks>
          This constructor is called during deserialization to reconstitute the
          exception object transmitted over a stream, e.g. from Remoting.
        </remarks>
            <altmember cref="M:NDesk.Options.OptionException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
        </member>
        <member name="C:NDesk.Options.OptionException(System.String,System.String)">
            <param name="message">
          A <see cref="T:System.String" /> that describes the error.
        </param>
            <param name="optionName">
          A <see cref="T:System.String" /> that contains the name of the
		      option that caused the exception.
        </param>
            <summary>
          Creates and initializes a new instance of the 
          <see cref="T:NDesk.Options.OptionException" /> class.
        </summary>
            <remarks>
          This constructor initializes the 
          <see cref="P:System.Exception.Message" /> property of the new
          instance using <paramref name="message" />, and the 
          <see cref="P:NDesk.Options.OptionException.OptionName" />
          property of the new instance using <paramref name="optionName" />.
        </remarks>
        </member>
        <member name="C:NDesk.Options.OptionException(System.String,System.String,System.Exception)">
            <param name="message">
          A <see cref="T:System.String" /> that describes the error.
        </param>
            <param name="optionName">
          A <see cref="T:System.String" /> that contains the name of the
          option that caused the exception.
        </param>
            <param name="innerException">
          An instance of <see cref="T:System.Exception" /> that is the cause
          of the current exception.  If <paramref name="innerException" /> is
          non-<see langword="null" />, then the current Exception was raised
          in a catch block handling <paramref name="innerException" />.
        </param>
            <summary>
          Creates and initializes a new instance of the 
          <see cref="T:NDesk.Options.OptionException" /> class.
        </summary>
            <remarks>
          This constructor initializes the 
          <see cref="P:System.Exception.Message" /> property of the new
          instance using <paramref name="message" />, the
          <see cref="P:System.Exception.InnerException" /> property of the new
          instance using <paramref name="innerException" />, and the 
          <see cref="P:NDesk.Options.OptionException.OptionName" />
          property of the new instance using <paramref name="optionName" />.
        </remarks>
        </member>
        <member name="M:NDesk.Options.OptionException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <param name="info">
          The <see cref="T:System.Runtime.Serialization.SerializationInfo" />
          that holds the serialized object data about the exception being
          thrown.
        </param>
            <param name="context">
          The <see cref="T:System.Runtime.Serialization.StreamingContext" />
          that contains contextual information about the source or
          destination.
        </param>
            <summary>
          Adds information about the exception to the provided 
          <see cref="T:System.Runtime.Serialization.SerializationInfo" /> 
          instance.
        </summary>
            <remarks>
          Adds information about this exception instance to the provided 
          <see cref="T:System.Runtime.Serialization.SerializationInfo" />,
          so that a new cloned instance may be properly reconstituted later.
        </remarks>
            <altmember cref="C:NDesk.Options.OptionException(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
        </member>
        <member name="P:NDesk.Options.OptionException.OptionName">
            <summary>
          A <see cref="T:System.String" /> containing the option name that 
          caused the exception.
        </summary>
            <value>
          A <see cref="T:System.String" /> containing the option name that 
          caused the exception.
        </value>
            <remarks />
        </member>
        <member name="T:NDesk.Options.OptionSet">
            <summary>
      A class to parse program options.
    </summary>
            <remarks>
                <para>
        A common requirement for command-line programs is option parsing.  
        The command line consists of a sequence of 
        <paramref name="arguments" />.  
        <see cref="M:NDesk.Options.OptionSet.Parse(System.Collections.Generic.IEnumerable{System.String})" />
        parses this argument
        sequence, invoking actions of registered 
        <see cref="T:NDesk.Options.Option" />s when a sequence of arguments 
        matching the <see cref="T:NDesk.Options.Option" />s requirements are
        encountered.  <see cref="T:NDesk.Options.Option" />'s are registered 
        with <see cref="M:NDesk.Options.OptionSet.Add(NDesk.Options.Option)" />
        and its overloads.
      </para>
                <para>
                    <see cref="M:NDesk.Options.OptionSet.Parse(System.Collections.Generic.IEnumerable{System.String})" />,
        returns a 
        <see cref="T:System.Collections.Generic.List{System.String}" /> of all
        arguments which were not matched by a registered
        <see cref="T:NDesk.Options.Option" />.
      </para>
                <para>
        Three conditions must be met for a sequence of arguments to be
        considered as a match for an <see cref="T:NDesk.Options.Option" />:
      </para>
                <list type="bullet">
                    <item>
                        <term>
          The <paramref name="name" /> must be matched.  An 
          <see cref="T:NDesk.Options.Option" /> has one or more names, as
          returned from <see cref="M:NDesk.Options.Option.GetNames" />.
          Matched names must start with a <paramref name="flag" /> 
          (even though the flag is not part of the
          <see cref="P:NDesk.Options.Option.Prototype" />): <c>-</c>, 
          <c>--</c>, or <c>/</c>.
          There are several different name matching algorithms:
          <list type="bullet"><item><term><para><paramref name="Simple" /> names are matched when the argument
                consists solely of a flag followed by an option name.
              </para><para>
                Examples: <c>-opt</c>, <c>--opt</c>, and <c>/opt</c> are all
                simple names for the <c>opt</c> option.
              </para></term></item><item><term><para><paramref name="Boolean" /> names are matched when the
                argument consists of a flag, followed by an option name,
                followed by <c>+</c> or <c>-</c>.  If a <c>+</c> follows the
                name, the option is enabled, otherwise the option is disabled.
              </para><para>
                Examples: <c>-opt+</c> and <c>-opt-</c> enable and disble the
                <c>opt</c> option.
              </para></term></item><item><term><para><paramref name="Assigned" /> names are matched when the
                argument consists of a flag, followed by an option name,
                followed by a <c>=</c> or <c>:</c>, followed by an (optional)
                string.
              </para><para>
                Examples: <c>-opt=A</c>, <c>--opt:B</c>, and <c>/opt=C</c> all
                provide a value for the <c>opt</c> option.
              </para></term></item><item><term><para><paramref name="Bundled" /> names are matched only when
                simple, boolean, and assigned names are not matched,
                the flag is <c>-</c>, and the first character matches a
                registered option.  Any number of (single-character) boolean 
                options may be bundled in this fashion, and at most one
                <see cref="F:NDesk.Options.OptionValueType.Optional" /> or
                <see cref="F:NDesk.Options.OptionValueType.Required" /> option 
                (which will use all remaining characters within the argument
                as a value).
              </para><para>
                Examples: <c>-xvfinput-file</c> could match the boolean 
                <see cref="T:NDesk.Options.Option" />s <c>x</c> and <c>v</c>
                and the value-accepting option <c>f</c>, which will get the
                value <c>input-file</c>.  (Other interpretations are also
                possible, depending upon which options are registered.)
              </para></term></item><item><term><para>
                  As a fallback, a <paramref name="default handler" /> may be
                  registered which will handle <paramref name="all" />
                  arguments which are not handled by any of the above matching
                  algorithms.  The default handler is designated by the name
                  <c>&lt;&gt;</c> (which may be an alias for another named
                  <see cref="T:NDesk.Options.Option" />).
                </para><para>
                  Default handlers are useful for argument runs -- sequences
                  of arguments that are not related to each other but are
                  instead related to a prior option on the command line, and it
                  isn't desirable to use named options for these.  For
                  example, <c>mdoc-assemble --format=ecma DirA DirB 
                  --format=man FileC</c> would process <c>DirA</c> and
                  <c>DirB</c> with <c>--format=ecma</c> in effect, and then
                  process <c>FileC</c> with <c>--format=man</c> in effect.
                </para><para>
                  See 
                  <see cref="C:NDesk.Options.Option(System.String,System.String,System.Int32)" />
                  for additional details regarding default option handlers.
                </para></term></item></list></term>
                    </item>
                    <item>
                        <term>
          The <paramref name="type" /> must be matched.  
          <see cref="P:NDesk.Options.Option.OptionValueType" /> specifies the
          option's type.  See below for more information.
        </term>
                    </item>
                    <item>
                        <term>
          The <paramref name="value count" /> must be matched.  Whether an
          option takes any values is dependent upon the option's type
          (previous bullet), but the number of values the option either
          accepts or requires is specified by the
          <see cref="P:NDesk.Options.Option.MaxValueCount" /> property.
        </term>
                    </item>
                </list>
                <para>
        There are three types of <see cref="T:NDesk.Options.Option" />s that
        can be parsed:
      </para>
                <list type="number">
                    <item>
                        <term>
          Boolean options, which correspond to a 
          <see cref="P:NDesk.Options.Option.OptionValueType" /> value of
          <see cref="F:NDesk.Options.OptionValueType.None" />.
          When a matching argument is encountered, their registered
          action is invoked immediately.  The <see cref="T:System.Action`1" />
          value will be non-<see langword="default(T)" /> if the value is true,
          e.g.  if <c>-option</c> or <c>-option+</c> is specified, and the value
          will be <see langword="default(T)" /> if the value is false, e.g. 
          if <c>-option-</c> is specified.
        </term>
                    </item>
                    <item>
                        <term>
                            <para>
            Optional value options, which correspond to a 
            <see cref="P:NDesk.Options.Option.OptionValueType" /> value of
            <see cref="F:NDesk.Options.OptionValueType.Optional" />.
            Optional value options are not "greedy"; they will only get their
            value only from the current argument.  If the value is not present, 
            <see langword="default(T)" /> is provided to their corresponding
            <see cref="T:System.Action`1" />.
          </para>
                            <para>
            Thus, <c>-opt:value</c> would pass <c>value</c> to the
            action registered for <c>opt</c>, while <c>-opt value</c> would pass
            <see langword="default(T)" /> to the action registered for 
            <c>opt</c> and <c>value</c> would be an unparsed argument.
          </para>
                        </term>
                    </item>
                    <item>
                        <term>
                            <para>
            Required value options, which correspond to a 
            <see cref="P:NDesk.Options.Option.OptionValueType" /> value of
            <see cref="F:NDesk.Options.OptionValueType.Required" />.
            Required value options are "greedy" -- if the value is not found
            within the current argument, the following argument(s) will be used to
            supply the value(s).  Once enough values have been parsed, 
            their corresponding <see cref="T:System.Action`1" /> is invoked.
          </para>
                            <para>
            Thus, both <c>-opt:value</c> and <c>-opt value</c> would pass 
            <c>value</c> to the action registered for <c>opt</c>.
          </para>
                            <para>
            If no value can be found, an 
            <see cref="T:NDesk.Options.OptionException" /> is thrown from
            <see cref="M:NDesk.Options.OptionSet.Parse(System.Collections.Generic.IEnumerable{System.String})" />.
          </para>
                        </term>
                    </item>
                </list>
                <block subset="none" type="behaviors">
                    <para>
          Use of <c>OptionSet</c> is split up into two parts:
        </para>
                    <list type="number">
                        <item>
                            <term>Initialization.</term>
                        </item>
                        <item>
                            <term>Parsing.</term>
                        </item>
                    </list>
                    <para>
          During the <paramref name="initialization" /> phase, new
          <see cref="T:NDesk.Options.Option" /> instances are created and
          associated with an action to perform when the <c>Option</c>
          requirements are met (e.g. when a required value has been
          encountered).  This phase is not thread safe.
          All options added during this phase are considered to have been
          <paramref name="registered" />.
        </para>
                    <code lang="C#">OptionSet p = new OptionSet () {
  { "option-a", v =&gt; { /* action to perform */ } },
};</code>
                    <para>
          There are three ways to add <see cref="T:NDesk.Options.Option" />s
          to the <see cref="T:NDesk.Options.OptionSet" />:
        </para>
                    <list type="number">
                        <item>
                            <term>
            With C# collection initializers, as used above.
          </term>
                        </item>
                        <item>
                            <term>
            Explicitly by calling
            <see cref="M:NDesk.Options.OptionSet.Add(System.String,System.Action{System.String})" />
            and the other <c>Add</c> overloads.
          </term>
                        </item>
                        <item>
                            <term>
            By creating a new subclass of <see cref="T:NDesk.Options.Option" />
            and adding it via 
            <see cref="M:NDesk.Options.OptionSet.Add(NDesk.Options.Option)" />.
            This is not recommended, but is available if you require more
            direct option handling than the default 
            <see cref="T:NDesk.Options.Option" /> implementation provides.
          </term>
                        </item>
                    </list>
                    <para>
          During the <paramref name="parsing" /> phase, an
          <see cref="T:System.Collections.Generic.IEnumerable{System.String}" />
          is enumerated, looking for arguments which match a registered option,
          and invoking the corresponding action when an option and associated
          (optional) value is encountered.  During this phase, the 
          <see cref="T:NDesk.Options.OptionSet" /> instance itself is thread
          safe, but full thread safety depends upon thread-safety of the
          registered actions.  Any option-like strings for names that haven't
          been registered, e.g. <c>--this-was-never-registered=false</c>, and
          all arguments that are not used as option values are returned from 
          <see cref="M:NDesk.Options.OptionSet.Parse(System.Collections.Generic.IEnumerable{System.String})" />
          or processed by the default handler <c>&lt;&gt;</c>, if registered.
        </para>
                    <code lang="C#">List&lt;string&gt; extra = p.Parse (new string[]{"-option-a"});</code>
                </block>
                <block subset="none" type="overrides">
                    <para>
          Subclasses can override the following <see langword="virtual" /> 
          methods to customize option parsing behavior:
        </para>
                    <list type="bullet">
                        <item>
                            <term>
                                <see cref="M:NDesk.Options.OptionSet.Parse(System.String,NDesk.Options.OptionContext)" />
                            </term>
                        </item>
                        <item>
                            <term>
                                <see cref="M:NDesk.Options.OptionSet.CreateOptionContext" />
                            </term>
                        </item>
                    </list>
                </block>
            </remarks>
            <example>
                <para>
        The following example demonstrates some simple usage of 
        <see cref="T:NDesk.Options.OptionSet" />.
      </para>
                <code lang="C#" src="examples/greet.cs">using System;
using System.Collections.Generic;
using NDesk.Options;

class Test {
	static int verbosity;

	public static void Main (string[] args)
	{
		bool show_help = false;
		List&lt;string&gt; names = new List&lt;string&gt; ();
		int repeat = 1;

		var p = new OptionSet () {
			{ "n|name=", "the {NAME} of someone to greet.",
			  v =&gt; names.Add (v) },
			{ "r|repeat=", 
				"the number of {TIMES} to repeat the greeting.\n" + 
					"this must be an integer.",
			  (int v) =&gt; repeat = v },
			{ "v", "increase debug message verbosity",
			  v =&gt; { if (v != null) ++verbosity; } },
			{ "h|help",  "show this message and exit", 
			  v =&gt; show_help = v != null },
		};

		List&lt;string&gt; extra;
		try {
			extra = p.Parse (args);
		}
		catch (OptionException e) {
			Console.Write ("greet: ");
			Console.WriteLine (e.Message);
			Console.WriteLine ("Try `greet --help' for more information.");
			return;
		}

		if (show_help) {
			ShowHelp (p);
			return;
		}

		string message;
		if (extra.Count &gt; 0) {
			message = string.Join (" ", extra.ToArray ());
			Debug ("Using new message: {0}", message);
		}
		else {
			message = "Hello {0}!";
			Debug ("Using default message: {0}", message);
		}

		foreach (string name in names) {
			for (int i = 0; i &lt; repeat; ++i)
				Console.WriteLine (message, name);
		}
	}

	static void ShowHelp (OptionSet p)
	{
		Console.WriteLine ("Usage: greet [OPTIONS]+ message");
		Console.WriteLine ("Greet a list of individuals with an optional message.");
		Console.WriteLine ("If no message is specified, a generic greeting is used.");
		Console.WriteLine ();
		Console.WriteLine ("Options:");
		p.WriteOptionDescriptions (Console.Out);
	}

	static void Debug (string format, params object[] args)
	{
		if (verbosity &gt; 0) {
			Console.Write ("# ");
			Console.WriteLine (format, args);
		}
	}
}

</code>
                <para>The output (under the influence of different command-line
        arguments) is:</para>
                <code lang="sh" src="examples/greet.txt">$ mono greet.exe --help
Usage: greet [OPTIONS]+ message
Greet a list of individuals with an optional message.
If no message is specified, a generic greeting is used.

Options:
  -n, --name=NAME            the NAME of someone to greet.
  -r, --repeat=TIMES         the number of TIMES to repeat the greeting.
                               this must be an integer.
  -v                         increase debug message verbosity
  -h, --help                 show this message and exit

$ mono greet.exe -v- -n A -name=B --name=C /name D -nE
Hello A!
Hello B!
Hello C!
Hello D!
Hello E!

$ mono greet.exe -v -n E custom greeting for: {0}
# Using new message: custom greeting for: {0}
custom greeting for: E

$ mono greet.exe -r 3 -n A
Hello A!
Hello A!
Hello A!

$ mono greet.exe -r not-an-int
greet: Could not convert string `not-an-int' to type Int32 for option `-r'.
Try `greet --help' for more information.
</code>
                <para>
        Notice how the output produced by <c>--help</c> uses the
        descriptions provided during <c>OptionSet</c> initialization.
        Notice that the <see cref="T:NDesk.Options.Option" /> requiring a 
        value (<c>n|name=</c>) can use multiple different forms of invocation,
        including: 
        <c>-n value</c>, 
        <c>-n=value</c>, 
        <c>-name value</c>, 
        <c>-name=value</c>, 
        <c>--name value</c>,
        <c>--name=value</c>,
        <c>/name value</c>, and
        <c>/name=value</c>.
      </para>
                <para>
        Notice also that the boolean <c>v</c> option can take three
        separate forms: <c>-v</c> and <c>-v+</c>, which both enable the option,
        and <c>-v-</c>, which disables the option.  (The second <c>greet</c>
        invocation uses <c>-v-</c>, which is why no debug messages are shown.)
      </para>
                <para>
        Finally, note that the action can specify a type to use.  If no type
        is provided, the action parameter will be a 
        <see cref="T:System.String" />.  If a type is provided, then
        <see cref="T:System.ComponentModel.TypeConverter" /> will be used to
        convert a string to the specified type.
      </para>
            </example>
            <example>
                <para>
        The following example shows how options and values can be bundled
        together.
      </para>
                <code lang="C#" src="examples/bundling.cs">using System;
using System.Linq;
using System.Collections.Generic;
using NDesk.Options;

class Test {
	public static void Main (string[] args)
	{
		var show_help = false;
		var macros = new Dictionary&lt;string, string&gt;();
		bool create = false, extract = false, list = false;
		string output = null, input = null;
		string color  = null;

		var p = new OptionSet () {
			// gcc-like options
			{ "D:", "Predefine a macro with an (optional) value.",
				(m, v) =&gt; {
					if (m == null)
						throw new OptionException ("Missing macro name for option -D.", 
								"-D");
					macros.Add (m, v);
				} },
			{ "d={--&gt;}{=&gt;}", "Alternate macro syntax.", 
				(m, v) =&gt; macros.Add (m, v) },
			{ "o=", "Specify the output file", v =&gt; output = v },

			// tar-like options
			{ "f=", "The input file",   v =&gt; input = v },
			{ "x",  "Extract the file", v =&gt; extract = v != null },
			{ "c",  "Create the file",  v =&gt; create = v != null },
			{ "t",  "List the file",    v =&gt; list = v != null },

			// ls-like optional values
			{ "color:", "control whether and when color is used", 
				v =&gt; color = v },

			// other...
			{ "h|help",  "show this message and exit", 
			  v =&gt; show_help = v != null },
			// default
			{ "&lt;&gt;",
				v =&gt; Console.WriteLine ("def handler: color={0}; arg={1}", color, v)},
		};

		try {
			p.Parse (args);
		}
		catch (OptionException e) {
			Console.Write ("bundling: ");
			Console.WriteLine (e.Message);
			Console.WriteLine ("Try `greet --help' for more information.");
			return;
		}

		if (show_help) {
			ShowHelp (p);
			return;
		}

		Console.WriteLine ("Macros:");
		foreach (var m in (from k in macros.Keys orderby k select k)) {
			Console.WriteLine ("\t{0}={1}", m, macros [m] ?? "&lt;null&gt;");
		}
		Console.WriteLine ("Options:");
		Console.WriteLine ("\t Input File: {0}", input);
		Console.WriteLine ("\tOuptut File: {0}", output);
		Console.WriteLine ("\t     Create: {0}", create);
		Console.WriteLine ("\t    Extract: {0}", extract);
		Console.WriteLine ("\t       List: {0}", list);
		Console.WriteLine ("\t      Color: {0}", color ?? "&lt;null&gt;");
	}

	static void ShowHelp (OptionSet p)
	{
		Console.WriteLine ("Usage: bundling [OPTIONS]+");
		Console.WriteLine ("Demo program to show the effects of bundling options and their values");
		Console.WriteLine ();
		Console.WriteLine ("Options:");
		p.WriteOptionDescriptions (Console.Out);
	}
}

</code>
                <para>
        The output (under the influence of different command-line arguments) is:
      </para>
                <code lang="sh" src="examples/bundling.txt">$ mono bundling.exe --help
Usage: bundling [OPTIONS]+
Demo program to show the effects of bundling options and their values

Options:
  -D[=VALUE1:VALUE2]         Predefine a macro with an (optional) value.
  -d=VALUE1--&gt;VALUE2         Alternate macro syntax.
  -o=VALUE                   Specify the output file
  -f=VALUE                   The input file
  -x                         Extract the file
  -c                         Create the file
  -t                         List the file
      --color[=VALUE]        control whether and when color is used
  -h, --help                 show this message and exit

$ mono bundling.exe -D
bundling: Missing macro name for option -D.
Try `greet --help' for more information.

$ mono bundling.exe -DA -DB=C "-dD--&gt;E" "-dF=&gt;G" -d "H=&gt;I" -cf input --color -ooutput
Macros:
	A=&lt;null&gt;
	B=C
	D=E
	F=G
	H=I
Options:
	 Input File: input
	Ouptut File: output
	     Create: True
	    Extract: False
	       List: False
	      Color: &lt;null&gt;

$ mono bundling.exe -cfv input
def handler: color=; arg=input
Macros:
Options:
	 Input File: v
	Ouptut File: 
	     Create: True
	    Extract: False
	       List: False
	      Color: &lt;null&gt;

$ mono bundling.exe -xctf input
Macros:
Options:
	 Input File: input
	Ouptut File: 
	     Create: True
	    Extract: True
	       List: True
	      Color: &lt;null&gt;

$ mono bundling.exe --color=auto -o output -finput
Macros:
Options:
	 Input File: input
	Ouptut File: output
	     Create: False
	    Extract: False
	       List: False
	      Color: auto

$ mono bundling.exe --color=on A B --color=off C D
def handler: color=on; arg=A
def handler: color=on; arg=B
def handler: color=off; arg=C
def handler: color=off; arg=D
Macros:
Options:
	 Input File: 
	Ouptut File: 
	     Create: False
	    Extract: False
	       List: False
	      Color: off
</code>
            </example>
            <example>
                <para>
        The following example shows a custom <c>OptionSet</c> subclass with
        the following additional functionality:
      </para>
                <list type="number">
                    <item>
                        <term>
          Option name lookup is done in a case insensitive fashion, so
          <c>--name</c> and <c>--NAME</c> are identical.
        </term>
                    </item>
                    <item>
                        <term>
          Option-like strings cannot be used as values to options, so
          <c>--name --repeat</c> is an error.
        </term>
                    </item>
                    <item>
                        <term>
          A key/value parser is provided, to show the use of custom 
          <see cref="T:NDesk.Options.OptionContext" /> and
          <see cref="T:NDesk.Options.Option" /> subclasses.
        </term>
                    </item>
                </list>
                <code lang="C#" src="examples/subclass.cs">// Case-Insensitive and Concatenating OptionSet
using System;
using System.Collections.Generic;
using NDesk.Options;

class DemoOptionSet : OptionSet {
	protected override void InsertItem (int index, Option item)
	{
		if (item.Prototype.ToLower () != item.Prototype)
			throw new ArgumentException ("prototypes must be lower-case!");
		base.InsertItem (index, item);
	}

	protected override OptionContext CreateOptionContext ()
	{
		return new OptionContext (this);
	}

	protected override bool Parse (string option, OptionContext c)
	{
		string f, n, s, v;
		bool haveParts = GetOptionParts (option, out f, out n, out s, out v);
		Option nextOption = null;
		string newOption  = option;

		if (haveParts) {
			string nl = n.ToLower ();
			nextOption = Contains (nl) ? this [nl] : null;
			newOption = f + n.ToLower () + (v != null ? s + v : "");
		}

		if (c.Option != null) {
			// Prevent --a --b
			if (c.Option != null &amp;&amp; haveParts) {
				if (nextOption == null) {
					// ignore
				}
				else 
					throw new OptionException (
						string.Format ("Found option `{0}' as value for option `{1}'.",
							option, c.OptionName), c.OptionName);
			}

			// have a option w/ required value; try to concat values.
			if (AppendValue (option, c)) {
				if (!option.EndsWith ("\\") &amp;&amp; 
						c.Option.MaxValueCount == c.OptionValues.Count) {
					c.Option.Invoke (c);
				}
				return true;
			}
			else
				base.Parse (newOption, c);
		}

		if (!haveParts || v == null) {
			// Not an option; let base handle as a non-option argument.
			return base.Parse (newOption, c);
		}

		if (nextOption.OptionValueType != OptionValueType.None &amp;&amp; 
				v.EndsWith ("\\")) {
			c.Option = nextOption;
			c.OptionValues.Add (v);
			c.OptionName = f + n;
			return true;
		}

		return base.Parse (newOption, c);
	}

	private bool AppendValue (string value, OptionContext c)
	{
		bool added = false;
		string[] seps = c.Option.GetValueSeparators ();
		foreach (var o in seps.Length != 0
				? value.Split (seps, StringSplitOptions.None)
				: new string[]{value}) {
			int idx = c.OptionValues.Count-1;
			if (idx == -1 || !c.OptionValues [idx].EndsWith ("\\")) {
				c.OptionValues.Add (o);
				added = true;
			}
			else {
				c.OptionValues [idx] += value;
				added = true;
			}
		}
		return added;
	}
}

class Demo {
	public static void Main (string[] args)
	{
		List&lt;string&gt; names = new List&lt;string&gt; ();
		Dictionary&lt;string,string&gt; map = new Dictionary&lt;string,string&gt; ();
		int repeat = 1;

		OptionSet p = new DemoOptionSet () {
			{ "n|name=",    v =&gt; names.Add (v) },
			{ "r|repeat:",  (int v) =&gt; repeat = v },
			{ "m|map=",     (k,v) =&gt; map.Add (k, v) },
		};

		List&lt;string&gt; extra;
		try {
			extra = p.Parse (args);
		}
		catch (OptionException e) {
			Console.Write ("subclass: ");
			Console.WriteLine (e.Message);
			return;
		}

		string message;
		if (extra.Count &gt; 0) {
			message = string.Join (" ", extra.ToArray ());
		}
		else {
			message = "Hello {0}!";
		}

		foreach (string name in names) {
			for (int i = 0; i &lt; repeat; ++i)
				Console.WriteLine (message, name);
		}
		List&lt;string&gt; keys = new List&lt;string&gt;(map.Keys);
		keys.Sort ();
		foreach (string key in keys) {
			Console.WriteLine ("Key: {0}={1}", key, map [key]);
		}
	}
}

</code>
                <para>The output (under the influence of different command-line
        arguments) is:
      </para>
                <code lang="sh" src="examples/subclass.txt">$ mono subclass.exe -n A -Name=B --NAME=C /nAMe D
Hello A!
Hello B!
Hello C!
Hello D!

$ mono subclass.exe --Repeat -name A

$ mono subclass.exe -Name --Repeat 3
subclass: Found option `--Repeat' as value for option `-name'.

$ mono subclass.exe --Map a b -mAp c=d /maP=e=f
Key: a=b
Key: c=d
Key: e=f

$ mono subclass.exe --map 'a\' 'b\' c 'd\' 'e\' f
Key: a\b\c=d\e\f
</code>
                <para>Notice:</para>
                <list type="bullet">
                    <item>
                        <term>
          That <c>--name</c> is treated in a case-insensitive fashion.
        </term>
                    </item>
                    <item>
                        <term>
          That <c>repeat</c> has an optional value, so with 
          <c>--Repeat -name A</c> the default <c>int</c> value is passed (0),
          so no message is printed.
        </term>
                    </item>
                    <item>
                        <term>
          That <c>name</c> has a required value, so 
          <c>-Name --Repeat 3</c> generates an error.
        </term>
                    </item>
                    <item>
                        <term>
          The <c>DemoOptionSet.Add()</c> method provides appropriate key/value
          option pairs to the callback method.
        </term>
                    </item>
                </list>
            </example>
        </member>
        <member name="C:NDesk.Options.OptionSet">
            <summary>
          Creates and initializes a new 
          <see cref="T:NDesk.Options.OptionSet" /> class instance.
        </summary>
            <remarks>
                <para>
            This constructor causes the created 
            <see cref="T:NDesk.Options.OptionSet" /> instance to perform no
            translation of string messages; consequently, no localization is
            performed.
          </para>
            </remarks>
            <altmember cref="C:NDesk.Options.OptionSet(System.Converter{System.String,System.String})" />
        </member>
        <member name="C:NDesk.Options.OptionSet(System.Converter{System.String,System.String})">
            <param name="localizer">
          A <see cref="T:System.Converter{System.String,System.String}" />
          instance that will be used to translate strings.
        </param>
            <summary>
          Creates and initializes a new 
          <see cref="T:NDesk.Options.OptionSet" /> class instance.
        </summary>
            <remarks>
                <para>
            This constructor initializes the 
            <see cref="P:NDesk.Options.OptionSet.MessageLocalizer" /> property
            of the new instance using <paramref name="localizer" />.
          </para>
                <para>
            Use this constructor when you want to perform some form of
            localization or internationalization on text strings generated
            from the <see cref="T:NDesk.Options.OptionSet" /> class.
            Generated strings include:
          </para>
                <list type="bullet">
                    <item>
                        <term>
              The <see cref="P:NDesk.Options.Option.Description" /> written by
              <see cref="M:NDesk.Options.OptionSet.WriteOptionDescriptions(System.IO.TextWriter)" />,
              but not the option names themselves.
            </term>
                    </item>
                    <item>
                        <term>
              Message format strings used when an error is encountered.
            </term>
                    </item>
                </list>
            </remarks>
            <example>
                <para>
            See the following example, which demonstrates how different
            localizers alter the program output.
          </para>
                <code lang="C#" src="examples/localization.cs">// Localization with NDesk.Options.OptionSet.
//
// Compile as:
//   gmcs -r:Mono.Posix.dll -r:NDesk.Options.dll code-localization.cs
using System;
using System.IO;
using Mono.Unix;
using NDesk.Options;

class LocalizationDemo {
	public static void Main (string[] args)
	{
		bool with_gettext = false;
		string useLocalizer = null;
		var p = new OptionSet () {
			{ "with-gettext", v =&gt; { useLocalizer = "gettext"; } },
			{ "with-hello",   v =&gt; { useLocalizer = "hello"; } },
			{ "with-default", v =&gt; { /* do nothing */ } },
		};
		p.Parse (args);

		Converter&lt;string, string&gt; localizer = f =&gt; f;
		switch (useLocalizer) {
			case "gettext":
				Catalog.Init ("localization", 
						Path.Combine (AppDomain.CurrentDomain.BaseDirectory,
							"locale"));
				localizer = f =&gt; { return Catalog.GetString (f); };
				break;
			case "hello":
				localizer = f =&gt; { return "hello:" + f; };;
				break;
		}

		bool help = false;
		int verbose = 0;
		bool version = false;
		p = new OptionSet (localizer) {
			{ "h|?|help", "show this message and exit.", 
				v =&gt; help = v != null },
			{ "v|verbose", "increase message verbosity.",
				v =&gt; { ++verbose; } },
			{ "n=", "must be an int",
				(int n) =&gt; { /* ignore */ } },
			{ "V|version", "output version information and exit.",
				v =&gt; version = v != null },
		};
		try {
			p.Parse (args);
		}
		catch (OptionException e) {
			Console.Write ("localization: ");
			Console.WriteLine (e.Message);
			return;
		}
		if (help)
			p.WriteOptionDescriptions (Console.Out);
		if (version)
			Console.WriteLine ("NDesk.Options Localizer Demo 1.0");
		if (verbose &gt; 0)
			Console.WriteLine ("Message level: {0}", verbose);
	}
}
</code>
                <para>The output (under the influence of different command-line
            arguments) is:</para>
                <code lang="sh" src="examples/localization.txt">$ mono localization.exe --help --version
  -h, -?, --help             show this message and exit.
  -v, --verbose              increase message verbosity.
  -n=VALUE                   must be an int
  -V, --version              output version information and exit.
NDesk.Options Localizer Demo 1.0

$ LANGUAGE=es mono localization.exe --with-gettext --help --version
  -h, -?, --help             A mostrar este mensaje y salir.
  -v, --verbose              Aumento mensaje verbosidad.
  -n=VALUE                   Debe ser un int
  -V, --version              Salida de información de versión y sale.
NDesk.Options Localizer Demo 1.0

$ mono localization.exe --with-hello --help --version
  -h, -?, --help             hello:show this message and exit.
  -v, --verbose              hello:increase message verbosity.
  -nhello:=VALUE             hello:must be an int
  -V, --version              hello:output version information and exit.
NDesk.Options Localizer Demo 1.0

$ mono localization.exe -n not-an-int
localization: Could not convert string `not-an-int' to type Int32 for option `-n'.

$ mono localization.exe --with-hello -n not-an-int
localization: hello:Could not convert string `not-an-int' to type Int32 for option `-n'.
</code>
                <para>Notice:</para>
                <list type="bullet">
                    <item>
                        <term>
              The <c>--with-gettext</c> parser uses 
              <see cref="M:Mono.Unix.Catalog.GetString" /> to translate all
              messages
            </term>
                    </item>
                    <item>
                        <term>
              The <c>-with-hello</c> parser prefixes all 
              descriptions with <c>hello:</c>.
            </term>
                    </item>
                    <item>
                        <term>
              Only the descriptions are translated, and not the command-line 
              arguments themselves.  Only error messages and 
              option descriptions are translated, not the options themselves.
            </term>
                    </item>
                </list>
            </example>
        </member>
        <member name="M:NDesk.Options.OptionSet.Add(NDesk.Options.Option)">
            <param name="option">
          The <see cref="T:NDesk.Options.Option" /> to register.
        </param>
            <summary>
          Registers <paramref name="option" /> so that any options matching
          <see cref="M:NDesk.Options.Option.GetNames" /> will be treated
          specially by 
          <see cref="M:NDesk.Options.OptionSet.Parse(System.Collections.Generic.IEnumerable{System.String})" />.
        </summary>
            <returns>
          The current <see cref="T:NDesk.Options.OptionSet" /> instance.
          This is to permit method chaining.
        </returns>
            <remarks>
          Registers each option name returned by 
          <see cref="M:NDesk.Options.Option.GetNames" />, ensuring that any
          option with a matching name will be handled by the 
          <paramref name="option" /> instance.
        </remarks>
            <exception cref="T:System.ArgumentException">
                <paramref name="option" /> has an alias (as returned from
          <see cref="M:NDesk.Options.Option.GetNames" />) that conflicts with
          a previously registered <see cref="T:NDesk.Options.Option" />.
        </exception>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="option" /> is <see langword="null" />.
        </exception>
        </member>
        <member name="M:NDesk.Options.OptionSet.Add(System.String,NDesk.Options.OptionAction{System.String,System.String})">
            <param name="prototype">
          A <see cref="T:System.String" /> containing all option aliases to
          register, an (optional) type specifier, and an (optional) value
          separator list; see 
          <see cref="C:NDesk.Options.Option(System.String,System.String,System.Int32)" />
          for details.
        </param>
            <param name="action">
          A <see cref="T:NDesk.Options.OptionAction{System.String,System.String}" />
          to invoke when an option is parsed.
        </param>
            <summary>
          Registers each alias within <paramref name="prototype" /> so that any 
          options matching the aliases in <paramref name="prototype" /> will be
          handled by <paramref name="action" /> during any subsequent
          <see cref="M:NDesk.Options.OptionSet.Parse(System.Collections.Generic.IEnumerable{System.String})" />
          calls.
        </summary>
            <returns>
          The current <see cref="T:NDesk.Options.OptionSet" /> instance.
          This is to permit method chaining.
        </returns>
            <remarks>
          Calls 
          <see cref="M:NDesk.Options.OptionSet.Add(System.String,System.String,NDesk.Options.OptionAction{System.String,System.String})" />
          with a <paramref name="description" /> value of 
          <see langword="null" />.
        </remarks>
            <altmember cref="M:NDesk.Options.OptionSet.Add(System.String,System.String,NDesk.Options.OptionAction{System.String,System.String})" />
            <altmember cref="M:NDesk.Options.OptionSet.Add(NDesk.Options.Option)" />
            <exception cref="T:System.ArgumentException">
                <paramref name="prototype" /> has an alias (as returned from
          <see cref="M:NDesk.Options.Option.GetNames" />) that conflicts with
          a previously registered <see cref="T:NDesk.Options.Option" />.
        </exception>
            <exception cref="T:System.ArgumentNullException">
                <para>
                    <paramref name="prototype" /> is <see langword="null" /></para>
                <para>-or-</para>
                <para>
                    <paramref name="action" /> is <see langword="null" /></para>
            </exception>
        </member>
        <member name="M:NDesk.Options.OptionSet.Add(System.String,System.Action{System.String})">
            <param name="prototype">
          A <see cref="T:System.String" /> containing all option aliases to
          register, an (optional) type specifier, and an (optional) value
          separator list; see 
          <see cref="C:NDesk.Options.Option(System.String,System.String,System.Int32)" />
          for details.
        </param>
            <param name="action">
          A <see cref="T:System.Action{System.String}" />
          to invoke when an option is parsed.
        </param>
            <summary>
          Registers each alias within <paramref name="prototype" /> so that any 
          options matching the aliases in <paramref name="prototype" /> will be
          handled by <paramref name="action" /> during any subsequent
          <see cref="M:NDesk.Options.OptionSet.Parse(System.Collections.Generic.IEnumerable{System.String})" />
          calls.
        </summary>
            <returns>
          The current <see cref="T:NDesk.Options.OptionSet" /> instance.
          This is to permit method chaining.
        </returns>
            <remarks>
          Calls 
          <see cref="M:NDesk.Options.OptionSet.Add(System.String,System.String,System.Action{System.String})" />
          with a <paramref name="description" /> value of 
          <see langword="null" />.
        </remarks>
            <altmember cref="M:NDesk.Options.OptionSet.Add(System.String,System.String,System.Action{System.String})" />
            <altmember cref="M:NDesk.Options.OptionSet.Add(NDesk.Options.Option)" />
            <exception cref="T:System.ArgumentException">
                <paramref name="prototype" /> has an alias (as returned from
          <see cref="M:NDesk.Options.Option.GetNames" />) that conflicts with
          a previously registered <see cref="T:NDesk.Options.Option" />.
        </exception>
            <exception cref="T:System.ArgumentNullException">
                <para>
                    <paramref name="prototype" /> is <see langword="null" /></para>
                <para>-or-</para>
                <para>
                    <paramref name="action" /> is <see langword="null" /></para>
            </exception>
        </member>
        <member name="M:NDesk.Options.OptionSet.Add(System.String,System.String,NDesk.Options.OptionAction{System.String,System.String})">
            <param name="prototype">
          A <see cref="T:System.String" /> containing all option aliases to
          register, an (optional) type specifier, and an (optional) value
          separator list; see 
          <see cref="C:NDesk.Options.Option(System.String,System.String,System.Int32)" />
          for details.
        </param>
            <param name="description">
          A <see cref="T:System.String" /> to be used to initialize
          the <see cref="P:NDesk.Options.Option.Description" /> property.
        </param>
            <param name="action">
          A <see cref="T:NDesk.Options.OptionAction{System.String,System.String}" />
          to invoke when an option is parsed.
        </param>
            <summary>
          Registers each alias within <paramref name="prototype" /> so that any 
          options matching the aliases in <paramref name="prototype" /> will be
          handled by <paramref name="action" /> during any subsequent
          <see cref="M:NDesk.Options.OptionSet.Parse(System.Collections.Generic.IEnumerable{System.String})" />
          calls.
        </summary>
            <returns>
          The current <see cref="T:NDesk.Options.OptionSet" /> instance.
          This is to permit method chaining.
        </returns>
            <remarks>
                <para>
            Use this method when <paramref name="prototype" /> should accept
            two values, generally a key and a value.
          </para>
                <block subset="none" type="note">
            If <paramref name="prototype" /> specifies a 
            <see cref="F:NDesk.Options.OptionValueType.Optional" /> option,
            then it's possible that both the key and the value will be
            <see langword="null" /> in the callback function.
          </block>
            </remarks>
            <altmember cref="M:NDesk.Options.OptionSet.Add(NDesk.Options.Option)" />
            <exception cref="T:System.ArgumentException">
                <paramref name="prototype" /> has an alias (as returned from
          <see cref="M:NDesk.Options.Option.GetNames" />) that conflicts with
          a previously registered <see cref="T:NDesk.Options.Option" />.
        </exception>
            <exception cref="T:System.ArgumentNullException">
                <para>
                    <paramref name="prototype" /> is <see langword="null" /></para>
                <para>-or-</para>
                <para>
                    <paramref name="action" /> is <see langword="null" /></para>
            </exception>
        </member>
        <member name="M:NDesk.Options.OptionSet.Add(System.String,System.String,System.Action{System.String})">
            <param name="prototype">
          A <see cref="T:System.String" /> containing all option aliases to
          register, an (optional) type specifier, and an (optional) value
          separator list; see 
          <see cref="C:NDesk.Options.Option(System.String,System.String,System.Int32)" />
          for details.
        </param>
            <param name="description">
          A <see cref="T:System.String" /> containing to used to initialize
          the <see cref="P:NDesk.Options.Option.Description" /> property.
        </param>
            <param name="action">
          A <see cref="T:System.Action{System.String}" />
          to invoke when an option is parsed.
        </param>
            <summary>
          Registers each alias within <paramref name="prototype" /> so that any 
          options matching the aliases in <paramref name="prototype" /> will be
          handled by <paramref name="action" /> during any subsequent
          <see cref="M:NDesk.Options.OptionSet.Parse(System.Collections.Generic.IEnumerable{System.String})" />
          calls.
        </summary>
            <returns>
          The current <see cref="T:NDesk.Options.OptionSet" /> instance.
          This is to permit method chaining.
        </returns>
            <remarks />
            <altmember cref="M:NDesk.Options.OptionSet.Add(NDesk.Options.Option)" />
            <exception cref="T:System.ArgumentException">
                <paramref name="option" /> has an alias (as returned from
          <see cref="M:NDesk.Options.Option.GetNames" />) that conflicts with
          a previously registered <see cref="T:NDesk.Options.Option" />.
        </exception>
            <exception cref="T:System.ArgumentNullException">
                <para>
                    <paramref name="prototype" /> is <see langword="null" /></para>
                <para>-or-</para>
                <para>
                    <paramref name="action" /> is <see langword="null" /></para>
            </exception>
        </member>
        <member name="M:NDesk.Options.OptionSet.Add``1(System.String,System.Action{``0})">
            <typeparam name="T">
          The type of the option to parse and provide to the 
          <paramref name="action" /> callback.
        </typeparam>
            <param name="prototype">
          A <see cref="T:System.String" /> containing all option aliases to
          register, an (optional) type specifier, and an (optional) value
          separator list; see 
          <see cref="C:NDesk.Options.Option(System.String,System.String,System.Int32)" />
          for details.
        </param>
            <param name="action">
          A <see cref="T:System.Action{``0}" />
          to invoke when an option is parsed.
        </param>
            <summary>
          Registers each alias within <paramref name="prototype" /> so that any 
          options matching the aliases in <paramref name="prototype" /> will be
          handled by <paramref name="action" /> during any subsequent
          <see cref="M:NDesk.Options.OptionSet.Parse(System.Collections.Generic.IEnumerable{System.String})" />
          calls.
        </summary>
            <returns>
          The current <see cref="T:NDesk.Options.OptionSet" /> instance.
          This is to permit method chaining.
        </returns>
            <remarks>
          Calls 
          <see cref="M:NDesk.Options.OptionSet.Add``1(System.String,System.String,System.Action{``0})" />
          with a <paramref name="description" /> value of 
          <see langword="null" />.
        </remarks>
            <altmember cref="M:NDesk.Options.OptionSet.Add(NDesk.Options.Option)" />
            <altmember cref="M:NDesk.Options.OptionSet.Add``1(System.String,System.String,System.Action{``0})" />
            <exception cref="T:System.ArgumentException">
                <paramref name="option" /> has an alias (as returned from
          <see cref="M:NDesk.Options.Option.GetNames" />) that conflicts with
          a previously registered <see cref="T:NDesk.Options.Option" />.
        </exception>
        </member>
        <member name="M:NDesk.Options.OptionSet.Add``1(System.String,System.String,System.Action{``0})">
            <typeparam name="T">
          The type of the option to parse and provide to the 
          <paramref name="action" /> callback.
        </typeparam>
            <param name="prototype">
          A <see cref="T:System.String" /> containing all option aliases to
          register, an (optional) type specifier, and an (optional) value
          separator list; see 
          <see cref="C:NDesk.Options.Option(System.String,System.String,System.Int32)" />
          for details.
        </param>
            <param name="description">
          A <see cref="T:System.String" /> containing to used to initialize
          the <see cref="P:NDesk.Options.Option.Description" /> property.
        </param>
            <param name="action">
          A <see cref="T:System.Action{``0}" />
          to invoke when an option is parsed.
        </param>
            <summary>
          Registers each alias within <paramref name="prototype" /> so that any 
          options matching the aliases in <paramref name="prototype" /> will be
          handled by <paramref name="action" /> during any subsequent
          <see cref="M:NDesk.Options.OptionSet.Parse(System.Collections.Generic.IEnumerable{System.String})" />
          calls.
        </summary>
            <returns>
          The current <see cref="T:NDesk.Options.OptionSet" /> instance.
          This is to permit method chaining.
        </returns>
            <remarks>
                <para>
            Use this typed overload when you want strongly typed option values
            that correspond to a managed type.
            <see cref="M:System.ComponentModel.TypeDescriptor.GetConverter(System.Type)" />
            is used to lookup the
            <see cref="T:System.ComponentModel.TypeConverter" /> to use when
            performing the string-to-type conversion.
          </para>
                <para>
            Special support is provided for <see cref="T:System.Nullable{X}" />
            types; <see cref="T:System.ComponentModel.TypeConverter" />
            doesn't currently support their use, but if 
            <typeparamref name="T" /> is a nullable type, then this method
            will instead use the 
            <see cref="T:System.ComponentModel.TypeConverter" /> for the 
            <typeparamref name="X" /> type.  This allows straightforward use
            of nullable types, identical to using any other strongly typed
            value.
          </para>
                <block subset="none" type="note">
                    <para>
              If <paramref name="prototype" /> specifies an
              <see cref="F:NDesk.Options.OptionValueType.Optional" /> value
              and the value is not provided, then <c>default(T)</c> is
              provided as the value to <paramref name="action" />.
            </para>
                </block>
            </remarks>
            <altmember cref="M:NDesk.Options.OptionSet.Add(NDesk.Options.Option)" />
            <exception cref="T:System.ArgumentException">
                <paramref name="option" /> has an alias (as returned from
          <see cref="M:NDesk.Options.Option.GetNames" />) that conflicts with
          a previously registered <see cref="T:NDesk.Options.Option" />.
        </exception>
            <exception cref="T:System.ArgumentNullException">
                <para>
                    <paramref name="prototype" /> is <see langword="null" /></para>
                <para>-or-</para>
                <para>
                    <paramref name="action" /> is <see langword="null" /></para>
            </exception>
        </member>
        <member name="M:NDesk.Options.OptionSet.Add``2(System.String,NDesk.Options.OptionAction{``0,``1})">
            <typeparam name="TKey">
          The type of the first argument to parse and provide to the 
          <paramref name="action" /> callback.
        </typeparam>
            <typeparam name="TValue">
          The type of the second argument to parse and provide to the 
          <paramref name="action" /> callback.
        </typeparam>
            <param name="prototype">
          A <see cref="T:System.String" /> containing all option aliases to
          register, an (optional) type specifier, and an (optional) value
          separator list; see 
          <see cref="C:NDesk.Options.Option(System.String,System.String,System.Int32)" />
          for details.
        </param>
            <param name="action">
          A <see cref="T:NDesk.Options.OptionAction{TKey,TValue}" />
          to invoke when an option is parsed.
        </param>
            <summary>
          Registers each alias within <paramref name="prototype" /> so that any 
          options matching the aliases in <paramref name="prototype" /> will be
          handled by <paramref name="action" /> during any subsequent
          <see cref="M:NDesk.Options.OptionSet.Parse(System.Collections.Generic.IEnumerable{System.String})" />
          calls.
        </summary>
            <returns>
          The current <see cref="T:NDesk.Options.OptionSet" /> instance.
          This is to permit method chaining.
        </returns>
            <remarks>
          Calls 
          <see cref="M:NDesk.Options.OptionSet.Add``2(System.String,System.String,NDesk.Options.OptionAction{``0,``1})" />
          with a <paramref name="description" /> value of 
          <see langword="null" />.
        </remarks>
            <altmember cref="M:NDesk.Options.OptionSet.Add(NDesk.Options.Option)" />
            <altmember cref="M:NDesk.Options.OptionSet.Add``2(System.String,System.String,NDesk.Options.OptionAction{``0,``1})" />
            <exception cref="T:System.ArgumentException">
                <paramref name="prototype" /> has an alias (as returned from
          <see cref="M:NDesk.Options.Option.GetNames" />) that conflicts with
          a previously registered <see cref="T:NDesk.Options.Option" />.
        </exception>
            <exception cref="T:System.ArgumentNullException">
                <para>
                    <paramref name="prototype" /> is <see langword="null" /></para>
                <para>-or-</para>
                <para>
                    <paramref name="action" /> is <see langword="null" /></para>
            </exception>
        </member>
        <member name="M:NDesk.Options.OptionSet.Add``2(System.String,System.String,NDesk.Options.OptionAction{``0,``1})">
            <typeparam name="TKey">
          The type of the first argument to parse and provide to the 
          <paramref name="action" /> callback.
        </typeparam>
            <typeparam name="TValue">
          The type of the second argument to parse and provide to the 
          <paramref name="action" /> callback.
        </typeparam>
            <param name="prototype">
          A <see cref="T:System.String" /> containing all option aliases to
          register, an (optional) type specifier, and an (optional) value
          separator list; see 
          <see cref="C:NDesk.Options.Option(System.String,System.String,System.Int32)" />
          for details.
        </param>
            <param name="description">
          A <see cref="T:System.String" /> to be used to initialize
          the <see cref="P:NDesk.Options.Option.Description" /> property.
        </param>
            <param name="action">
          A <see cref="T:NDesk.Options.OptionAction{TKey,TValue}" />
          to invoke when an option is parsed.
        </param>
            <summary>
          Registers each alias within <paramref name="prototype" /> so that any 
          options matching the aliases in <paramref name="prototype" /> will be
          handled by <paramref name="action" /> during any subsequent
          <see cref="M:NDesk.Options.OptionSet.Parse(System.Collections.Generic.IEnumerable{System.String})" />
          calls.
        </summary>
            <returns>
          The current <see cref="T:NDesk.Options.OptionSet" /> instance.
          This is to permit method chaining.
        </returns>
            <remarks>
                <para>
            Use this method when <paramref name="prototype" /> should accept
            two typed values, generally a key and a value.
          </para>
                <block subset="none" type="note">
                    <para>
              If <paramref name="prototype" /> specifies an
              <see cref="F:NDesk.Options.OptionValueType.Optional" /> value
              and the value is not provided, then <c>default(TKey)</c> and
              <c>default(TValue)</c> may be provided as the values to
              <paramref name="action" />.
            </para>
                </block>
            </remarks>
            <altmember cref="M:NDesk.Options.OptionSet.Add(NDesk.Options.Option)" />
            <exception cref="T:System.ArgumentException">
                <paramref name="prototype" /> has an alias (as returned from
          <see cref="M:NDesk.Options.Option.GetNames" />) that conflicts with
          a previously registered <see cref="T:NDesk.Options.Option" />.
        </exception>
            <exception cref="T:System.ArgumentNullException">
                <para>
                    <paramref name="prototype" /> is <see langword="null" /></para>
                <para>-or-</para>
                <para>
                    <paramref name="action" /> is <see langword="null" /></para>
            </exception>
        </member>
        <member name="M:NDesk.Options.OptionSet.CreateOptionContext">
            <summary>
          Creates an <see cref="T:NDesk.Options.OptionContext" /> instance.
        </summary>
            <returns>
          A <see cref="T:NDesk.Options.OptionContext" /> instance to be used
          when parsing all options during the current
          <see cref="M:NDesk.Options.OptionSet.Parse(System.Collections.Generic.IEnumerable{System.String})" />
          call.
        </returns>
            <remarks>
                <block subset="none" type="overrides">
                    <para>
              This method can be overridden if
              <see cref="M:NDesk.Options.OptionSet.Parse(System.String,NDesk.Options.OptionContext)" />
              is overridden and requires access to an 
              <see cref="T:NDesk.Options.OptionContext" /> subclass to store
              additional information during the current 
              <see cref="M:NDesk.Options.OptionSet.Parse(System.Collections.Generic.IEnumerable{System.String})" />
              invocation.
            </para>
                </block>
            </remarks>
            <altmember cref="M:NDesk.Options.OptionSet.Parse(System.Collections.Generic.IEnumerable{System.String})" />
            <altmember cref="M:NDesk.Options.OptionSet.Parse(System.String,NDesk.Options.OptionContext)" />
        </member>
        <member name="M:NDesk.Options.OptionSet.GetKeyForItem(NDesk.Options.Option)">
            <param name="item">
          An <see cref="T:NDesk.Options.Option" /> to return the key of.
        </param>
            <summary>
          Returns <c><paramref name="item" />.GetNames()[0]</c>.
        </summary>
            <returns>
          A <see cref="T:System.String" /> containing the first alias returned
          by <see cref="M:NDesk.Options.Option.GetNames" />.
        </returns>
            <remarks>
                <para>
            This is to support the 
            <see cref="T:System.Collections.ObjectModel.KeyedCollection{System.String,NDesk.Options.Option}" />
            infrastructure.  
            <see cref="T:System.Collections.ObjectModel.KeyedCollection{System.String,NDesk.Options.Option}" />
            assumes only one key per item, so we arbitrarily choose the first
            item in the option alias list.
          </para>
                <block subset="none" type="note">
            All aliases returned by 
            <see cref="M:NDesk.Options.Option.GetNames" /> are still
            registered with 
            <see cref="T:System.Collections.ObjectModel.KeyedCollection{System.String,NDesk.Options.Option}" />
            even though 
            <see cref="M:NDesk.Options.OptionSet.GetKeyForItem(NDesk.Options.Option)" />
            will never return them.  Consequently, 
            <see cref="M:System.Collections.ObjectModel.KeyedCollection{System.String,NDesk.Options.Option}.Contains(`0)" />
            and
            <see cref="P:System.Collections.ObjectModel.KeyedCollection{System.String,NDesk.Options.Option}.Item(`0)" />
            will both correctly use all aliases returned by 
            <see cref="M:NDesk.Options.Option.GetNames" />.
          </block>
            </remarks>
        </member>
        <member name="M:NDesk.Options.OptionSet.GetOptionForName(System.String)">
            <param name="option">
          A <see cref="T:System.String" /> containing the option name to
          lookup.
        </param>
            <summary>
          Looks up the <see cref="T:NDesk.Options.Option" /> registered to
          handle the option name <paramref name="option" />.
        </summary>
            <returns>
          The <see cref="T:NDesk.Options.Option" /> instance registered to
          handle the option name <paramref name="option" />.
          If there is no registered handler for <paramref name="option" />,
          then <see langword="null" /> is returned.
        </returns>
            <remarks>
                <para>
            Subclasses can use this function to perform 
            <paramref name="option" /> lookup when overriding
            <see cref="M:NDesk.Options.OptionSet.Parse(System.String,NDesk.Options.OptionContext)" />.
          </para>
            </remarks>
            <altmember cref="M:NDesk.Options.OptionSet.Parse(System.String,NDesk.Options.OptionContext)" />
            <exception cref="T:System.ArgumentNullException">
                <paramref name="option" /> is <see langword="null" />.
        </exception>
        </member>
        <member name="M:NDesk.Options.OptionSet.GetOptionParts(System.String,System.String@,System.String@,System.String@,System.String@)">
            <param name="argument">
          A <see cref="T:System.String" /> containing the option to parse into
          its constituent parts.
        </param>
            <param name="flag">
          A <see cref="T:System.String" /> reference which will be set to 
          <see langword="null" /> if the method returns 
          <see langword="false" />, or set to the flag the option starts with
          if the method returns <see langword="true" />.
          Valid flags include: <c>-</c>, <c>--</c>, and <c>/</c>.
        </param>
            <param name="name">
          A <see cref="T:System.String" /> reference which will be set to 
          <see langword="null" /> if the method returns 
          <see langword="false" />, or set to the option name following a
          valid flag if the method returns <see langword="true" />.
          No lookup is made to determine that flag has been registered via a 
          prior call to 
          <see cref="M:NDesk.Options.OptionSet.Add(NDesk.Options.Option)" />
          or related overload.
        </param>
            <param name="sep">
          A <see cref="T:System.String" /> reference which will be set to 
          <see langword="null" /> if either the method returns 
          <see langword="false" /> or if <c>=</c> or <c>:</c> was not found
          within <paramref name="argument" />; if the method returns 
          <see langword="true" /> and <paramref name="argument" /> contains a
          <c>=</c> or <c>:</c>, then <paramref name="sep" /> will contain
          either <c>=</c> or <c>:</c>, whichever was found within 
          <paramref name="argument" />.
        </param>
            <param name="value">
          A <see cref="T:System.String" /> reference which will be set to 
          <see langword="null" /> if either the method returns 
          <see langword="false" /> or if <paramref name="sep" /> is null;
          if the method returns <see langword="true" /> and 
          <paramref name="sep" /> is not <see langword="null" />, then
          <paramref name="value" /> will contain all text after 
          <paramref name="sep" />.
        </param>
            <summary>
          Splits <paramref name="argument" /> into its constituent parts.
        </summary>
            <returns>
                <see langword="true" /> if <paramref name="argument" /> could be split
          into its constituent parts, and <paramref name="flag" /> and 
          <paramref name="name" /> are set (<paramref name="sep" /> and
          <paramref name="value" /> may not be set, depending on whether or
          not they are present within <paramref name="argument" />);
          <see langword="true" /> if <paramref name="argument" /> is not the
          possible start of a valid option.
        </returns>
            <remarks>
                <para>
            Subclasses can call this method from their 
            <see cref="M:NDesk.Options.OptionSet.Parse(System.String,NDesk.Options.OptionContext)" />
            method to determine whether a given string is an option, and to
            split the option up for further processing.
          </para>
                <para>
            For example, <c>GetOptionParts("foo", ...)</c> would return 
            <see langword="false" />, while 
            <c>GetOptionParts("--foo=bar", ...)</c>
            would result in <paramref name="flag" /> containing <c>--</c>, 
            <paramref name="name" /> containing <c>foo</c>, 
            <paramref name="sep" /> containing <c>=</c>, and
            <paramref name="value" /> containing <c>bar</c>.
          </para>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="argument" /> is <see langword="null" />.
        </exception>
        </member>
        <member name="M:NDesk.Options.OptionSet.InsertItem(System.Int32,NDesk.Options.Option)">
            <param name="index">
          A <see cref="T:System.Int32" /> specifying the index to insert 
          <paramref name="item" /> into.
        </param>
            <param name="item">
          The <see cref="T:NDesk.Options.Option" /> to insert.
        </param>
            <summary>
          Inserts <paramref name="item" /> at the specified 
          <paramref name="index" />.
        </summary>
            <remarks />
        </member>
        <member name="P:NDesk.Options.OptionSet.MessageLocalizer">
            <summary>
          Permits access to the message localization facility.
        </summary>
            <value>
          A <see cref="T:System.Converter{System.String,System.String}" />
          that can be used to localize messages.
        </value>
            <remarks>
                <para>
                    <see cref="T:NDesk.Options.Option" /> subclasses can use this
            property 
            (via <see cref="P:NDesk.Options.OptionContext.OptionSet" />) to
            perform message localization for their own exception messages.
          </para>
            </remarks>
            <altmember cref="C:NDesk.Options.OptionSet(System.Converter{System.String,System.String})" />
        </member>
        <member name="M:NDesk.Options.OptionSet.Parse(System.Collections.Generic.IEnumerable{System.String})">
            <param name="arguments">
          A <see cref="T:System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
          containing all arguments to parse.
        </param>
            <summary>
          Parses each <see cref="T:System.String" /> within 
          <paramref name="arguments" />, invoking any registered
          <paramref name="actions" /> if a registered option is encountered.
        </summary>
            <returns>
          A <see cref="T:System.Collections.Generic.List{System.String}" />
          containing all unhandled arguments.
        </returns>
            <remarks>
                <para>
            An argument is unhandled if:
          </para>
                <list type="bullet">
                    <item>
                        <term>
              There is no default handler registered (the <c>&lt;&gt;</c>
              handler).  If there is a default handler registered, then the
              default handler is invoked for otherwise-unhandled arguments.
            </term>
                    </item>
                    <item>
                        <term>
              The option starts with a flag such as <c>-</c>, <c>--</c>,
              <c>/</c>, and the option name following the flag is
              unregistered.
            </term>
                    </item>
                    <item>
                        <term>
              Or, the option does not start with a flag, and there is no prior
              parsed option that accepts a value that would use the argument as
              its value.
            </term>
                    </item>
                </list>
                <para>
            Furthermore, argument parsing (including default handler invocation)
            stops whenever the <c>--</c> option is
            encountered.  This is in accordance with GNU conventions, and
            is frequently used to permit users to provide option-like
            filenames, e.g. <c>ls -lF -- -l</c> to view the file <c>-l</c>
            instead of needing to use <c>ls -lF ./-l</c>.
          </para>
            </remarks>
            <exception cref="T:NDesk.Options.OptionException">
                <para>
            A value was not found for an <see cref="T:NDesk.Options.Option" />
            requiring a value.
          </para>
                <para>-or-</para>
                <para>
            An attempt was made to bundle together an option requiring a
            value.
          </para>
                <para>-or-</para>
                <para>
            An exception was generated when trying to convert the value to the
            type <typeparamref name="T" />, for options added with
            <see cref="M:NDesk.Options.OptionSet.Add``1(System.String,System.String,System.Action{``0})" />
            and related methods.  The originating exception is provided via
            the <see cref="P:System.Exception.InnerException" /> property.
          </para>
            </exception>
            <example>
                <para>
            The following example demonstrates some simple usage of 
            <see cref="T:NDesk.Options.OptionSet" />.
          </para>
                <code lang="C#" src="examples/greet.cs">using System;
using System.Collections.Generic;
using NDesk.Options;

class Test {
	static int verbosity;

	public static void Main (string[] args)
	{
		bool show_help = false;
		List&lt;string&gt; names = new List&lt;string&gt; ();
		int repeat = 1;

		var p = new OptionSet () {
			{ "n|name=", "the {NAME} of someone to greet.",
			  v =&gt; names.Add (v) },
			{ "r|repeat=", 
				"the number of {TIMES} to repeat the greeting.\n" + 
					"this must be an integer.",
			  (int v) =&gt; repeat = v },
			{ "v", "increase debug message verbosity",
			  v =&gt; { if (v != null) ++verbosity; } },
			{ "h|help",  "show this message and exit", 
			  v =&gt; show_help = v != null },
		};

		List&lt;string&gt; extra;
		try {
			extra = p.Parse (args);
		}
		catch (OptionException e) {
			Console.Write ("greet: ");
			Console.WriteLine (e.Message);
			Console.WriteLine ("Try `greet --help' for more information.");
			return;
		}

		if (show_help) {
			ShowHelp (p);
			return;
		}

		string message;
		if (extra.Count &gt; 0) {
			message = string.Join (" ", extra.ToArray ());
			Debug ("Using new message: {0}", message);
		}
		else {
			message = "Hello {0}!";
			Debug ("Using default message: {0}", message);
		}

		foreach (string name in names) {
			for (int i = 0; i &lt; repeat; ++i)
				Console.WriteLine (message, name);
		}
	}

	static void ShowHelp (OptionSet p)
	{
		Console.WriteLine ("Usage: greet [OPTIONS]+ message");
		Console.WriteLine ("Greet a list of individuals with an optional message.");
		Console.WriteLine ("If no message is specified, a generic greeting is used.");
		Console.WriteLine ();
		Console.WriteLine ("Options:");
		p.WriteOptionDescriptions (Console.Out);
	}

	static void Debug (string format, params object[] args)
	{
		if (verbosity &gt; 0) {
			Console.Write ("# ");
			Console.WriteLine (format, args);
		}
	}
}

</code>
            </example>
        </member>
        <member name="M:NDesk.Options.OptionSet.Parse(System.String,NDesk.Options.OptionContext)">
            <param name="argument">
          A <see cref="T:System.String" /> containing the current option to
          parse.
        </param>
            <param name="c">
          A <see cref="T:NDesk.Options.OptionContext" /> containing the
          current parser context.
        </param>
            <summary>
          Parses <paramref name="argument" /> and invokes
          <see cref="M:NDesk.Options.Option.Invoke(NDesk.Options.OptionContext)" /> 
          if appropriate.
        </summary>
            <returns>
          A <see cref="T:System.Boolean" /> specifying whether or not
          <paramref name="argument" /> was handled.
          If <see langword="false" />, then
          <see cref="M:NDesk.Options.OptionSet.Parse(System.Collections.Generic.IEnumerable{System.String})" />
          will return <paramref name="argument" /> as an unhandled option.
        </returns>
            <remarks>
                <para>
            This method is called for each <see cref="T:System.String" />
            within the <see cref="T:System.Collections.Generic.IEnumerable{System.String}" />
            provided to 
            <see cref="M:NDesk.Options.OptionSet.Parse(System.Collections.Generic.IEnumerable{System.String})" />,
            which thus gives this method a chance to parse a single option, or
            chain together multiple options to form a single option (as is
            necessary when an option and its value are separated, e.g. with
            <c>-option value</c>).
          </para>
                <block subset="none" type="behaviors">
                    <para>
              The default implementation will check 
              <see cref="P:NDesk.Options.OptionContext.Option" />, which is
              assumed to be a <see cref="T:NDesk.Options.Option" /> in need of
              a value.  If 
              <see cref="P:NDesk.Options.OptionContext.Option" /> is 
              non-<see langword="null" />, then <paramref name="argument" />
              is 
              <see cref="M:NDesk.Options.OptionValueCollection.Add(System.String)" />ed
              to <see cref="P:NDesk.Options.OptionContext.OptionValues" /> and
              <see cref="M:NDesk.Options.Option.Invoke(NDesk.Options.OptionContext)" />
              is invoked.
            </para>
                    <para>
              Next, <see cref="M:NDesk.Options.OptionSet.GetOptionParts(System.String,System.String@,System.String@,System.String@,System.String@)" />
              is invoked.  If <c>GetOptionParts</c> returns 
              <see langword="false" />, then <see langword="false" /> is
              returned from <c>Parse</c>.
            </para>
                    <para>
              Finally, check to see if the <paramref name="name" /> returned
              from <c>GetOptionParts</c> is registered; if it is, handle it
              appropriately.  If it isn't, check to see if 
              <paramref name="name" /> is a bundled option or a boolean
              option.  If <paramref name="name" /> isn't any registered
              option, then <see langword="false" /> is returned.
              Otherwise, <see langword="true" /> is returned.
            </para>
                </block>
                <block subset="none" type="overrides">
                    <para>
              Inheriting types can override this method if they want to
              customize the per-option parsing within the containing
              <see cref="M:NDesk.Options.OptionSet.Parse(System.Collections.Generic.IEnumerable{System.String})" />
              invocation.
            </para>
                    <para>
              Inheriting types should consider overriding 
              <see cref="M:NDesk.Options.OptionSet.CreateOptionContext" />
              if they want to store extra information for use and retrieval
              during each <c>Parse</c> invocation.
            </para>
                </block>
            </remarks>
            <altmember cref="M:NDesk.Options.OptionSet.CreateOptionContext" />
            <altmember cref="M:NDesk.Options.OptionSet.Parse(System.Collections.Generic.IEnumerable{System.String})" />
        </member>
        <member name="M:NDesk.Options.OptionSet.RemoveItem(System.Int32)">
            <param name="index">
          A <see cref="T:System.Int32" /> containing the index of the 
          <see cref="T:NDesk.Options.Option" /> to remove.
        </param>
            <summary>
          Removes the <see cref="T:NDesk.Options.Option" /> at the specified
          <paramref name="index" />.
        </summary>
            <remarks />
        </member>
        <member name="M:NDesk.Options.OptionSet.SetItem(System.Int32,NDesk.Options.Option)">
            <param name="index">
          A <see cref="T:System.Int32" /> containing the index of the 
          <see cref="T:NDesk.Options.Option" /> to change.
        </param>
            <param name="item">
          The new <see cref="T:NDesk.Options.Option" /> to set at
          <paramref name="index" />.
        </param>
            <summary>
          Removes the current <see cref="T:NDesk.Options.Option" /> at 
          <paramref name="index" /> and sets <paramref name="item" /> 
          as the value for the <paramref name="index" /> value.
        </summary>
            <remarks />
        </member>
        <member name="M:NDesk.Options.OptionSet.WriteOptionDescriptions(System.IO.TextWriter)">
            <param name="o">
          The <see cref="T:System.IO.TextWriter" /> to write option
          descriptions to.
        </param>
            <summary>
          Writes <see cref="T:NDesk.Options.Option" /> documentation to 
          <paramref name="o" />.
        </summary>
            <remarks>
                <para>
            For each <see cref="T:NDesk.Options.Option" /> previously added to
            the current instance, this method writes out a comma-separated
            list of all <see cref="M:NDesk.Options.Option.GetNames" />
            followed by the <see cref="P:NDesk.Options.Option.Description" />.
          </para>
                <para>
            The <see cref="P:NDesk.Options.Option.Description" /> is
            automatically wrapped so that output will flow nicely across
            multiple lines.  Wrapping is preferred at explicit embedded 
            newline characters (<c>\n</c>) or spaces, but words will be split
            (by adding a <c>-</c>) if necessary.
          </para>
                <para>
            Options requiring a value have <c>=VALUE</c> appended to their
            last name, while options with an optional value have
            <c>[=VALUE]</c> appended to their last name.
            The <c>VALUE</c> string can be changed by using a format
            specifier-like string within the 
            <see cref="P:NDesk.Options.Option.Description" />.
          </para>
                <para>
            For <see cref="T:NDesk.Options.Option" />s accepting one value,
            the string <c>{VALUE}</c> or <c>{0:VALUE}</c> can be used to
            explicitly provide the value name.  For <c>Option</c>s accepting
            more than one value, the leading number is used to specify which
            value the string is for.
          </para>
            </remarks>
            <example>
                <para>
            The following example initializes a
            <see cref="T:NDesk.Options.OptionSet" /> instance to accept a
            variety of parameters and provides a description for each
            parameter:
          </para>
                <code lang="C#" src="examples/greet.cs">using System;
using System.Collections.Generic;
using NDesk.Options;

class Test {
	static int verbosity;

	public static void Main (string[] args)
	{
		bool show_help = false;
		List&lt;string&gt; names = new List&lt;string&gt; ();
		int repeat = 1;

		var p = new OptionSet () {
			{ "n|name=", "the {NAME} of someone to greet.",
			  v =&gt; names.Add (v) },
			{ "r|repeat=", 
				"the number of {TIMES} to repeat the greeting.\n" + 
					"this must be an integer.",
			  (int v) =&gt; repeat = v },
			{ "v", "increase debug message verbosity",
			  v =&gt; { if (v != null) ++verbosity; } },
			{ "h|help",  "show this message and exit", 
			  v =&gt; show_help = v != null },
		};

		List&lt;string&gt; extra;
		try {
			extra = p.Parse (args);
		}
		catch (OptionException e) {
			Console.Write ("greet: ");
			Console.WriteLine (e.Message);
			Console.WriteLine ("Try `greet --help' for more information.");
			return;
		}

		if (show_help) {
			ShowHelp (p);
			return;
		}

		string message;
		if (extra.Count &gt; 0) {
			message = string.Join (" ", extra.ToArray ());
			Debug ("Using new message: {0}", message);
		}
		else {
			message = "Hello {0}!";
			Debug ("Using default message: {0}", message);
		}

		foreach (string name in names) {
			for (int i = 0; i &lt; repeat; ++i)
				Console.WriteLine (message, name);
		}
	}

	static void ShowHelp (OptionSet p)
	{
		Console.WriteLine ("Usage: greet [OPTIONS]+ message");
		Console.WriteLine ("Greet a list of individuals with an optional message.");
		Console.WriteLine ("If no message is specified, a generic greeting is used.");
		Console.WriteLine ();
		Console.WriteLine ("Options:");
		p.WriteOptionDescriptions (Console.Out);
	}

	static void Debug (string format, params object[] args)
	{
		if (verbosity &gt; 0) {
			Console.Write ("# ");
			Console.WriteLine (format, args);
		}
	}
}

</code>
                <para>
            Notice that when the above program is invoked with the
            <c>--help</c> parameter, 
            <see cref="M:NDesk.Options.OptionSet.WriteOptionDescriptions(System.IO.TextWriter)" />
            is used to generate the <see cref="T:NDesk.Options.Option" />
            description, that the <c>--repeat</c> description spans
            multiple lines, and that format specifiers such as <c>{NAME}</c>
            are used to provide a description for the option value:
          </para>
                <code lang="sh" src="examples/greet.txt">$ mono greet.exe --help
Usage: greet [OPTIONS]+ message
Greet a list of individuals with an optional message.
If no message is specified, a generic greeting is used.

Options:
  -n, --name=NAME            the NAME of someone to greet.
  -r, --repeat=TIMES         the number of TIMES to repeat the greeting.
                               this must be an integer.
  -v                         increase debug message verbosity
  -h, --help                 show this message and exit

$ mono greet.exe -v- -n A -name=B --name=C /name D -nE
Hello A!
Hello B!
Hello C!
Hello D!
Hello E!

$ mono greet.exe -v -n E custom greeting for: {0}
# Using new message: custom greeting for: {0}
custom greeting for: E

$ mono greet.exe -r 3 -n A
Hello A!
Hello A!
Hello A!

$ mono greet.exe -r not-an-int
greet: Could not convert string `not-an-int' to type Int32 for option `-r'.
Try `greet --help' for more information.
</code>
            </example>
        </member>
        <member name="T:NDesk.Options.OptionValueCollection">
            <summary>
      A collection of <see cref="T:System.String" /> values to use as values to
      <see cref="M:NDesk.Options.Option.OnParseComplete(NDesk.Options.OptionContext)" />.
    </summary>
            <remarks>
                <para>
        A <see cref="T:NDesk.Options.OptionValueCollection" /> instance is
        tied to a controlling <see cref="T:NDesk.Options.OptionContext" />
        instance, and its behavior is tied to the 
        <see cref="T:NDesk.Options.Option" /> that the 
        <see cref="P:NDesk.Options.OptionContext.Option" /> property returns.
      </para>
                <para>
        If <see cref="P:NDesk.Options.OptionContext.Option" /> refers to an
        <see cref="T:NDesk.Options.Option" /> with an 
        <see cref="T:NDesk.Options.OptionValueType" /> of
        <see cref="F:NDesk.Options.OptionValueType.Optional" />, then the
        <see cref="P:NDesk.Options.OptionValueCollection.Item(System.Int32)" />
        indexer will return <see langword="null" /> if 
        <paramref name="index" /> is less than 
        <see cref="P:NDesk.Options.Option.MaxValueCount" /> and 
        <paramref name="index" /> is otherwise invalid (i.e. there hasn't been
        a string <c>Add</c>ed for that <paramref name="index" />.
      </para>
                <para>
        Otherwise, this instance behaves like
        <see cref="T:System.Collections.Generic.List{System.String}" />.
      </para>
            </remarks>
        </member>
        <member name="M:NDesk.Options.OptionValueCollection.Add(System.String)">
            <param name="item">To be added.</param>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:NDesk.Options.OptionValueCollection.Clear">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:NDesk.Options.OptionValueCollection.Contains(System.String)">
            <param name="item">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:NDesk.Options.OptionValueCollection.CopyTo(System.String[],System.Int32)">
            <param name="array">To be added.</param>
            <param name="arrayIndex">To be added.</param>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:NDesk.Options.OptionValueCollection.Count">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:NDesk.Options.OptionValueCollection.GetEnumerator">
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:NDesk.Options.OptionValueCollection.IndexOf(System.String)">
            <param name="item">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:NDesk.Options.OptionValueCollection.Insert(System.Int32,System.String)">
            <param name="index">To be added.</param>
            <param name="item">To be added.</param>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:NDesk.Options.OptionValueCollection.IsReadOnly">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:NDesk.Options.OptionValueCollection.Item(System.Int32)">
            <param name="index">To be added.</param>
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:NDesk.Options.OptionValueCollection.Remove(System.String)">
            <param name="item">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:NDesk.Options.OptionValueCollection.RemoveAt(System.Int32)">
            <param name="index">To be added.</param>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:NDesk.Options.OptionValueCollection.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
            <param name="array">To be added.</param>
            <param name="index">To be added.</param>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:NDesk.Options.OptionValueCollection.System#Collections#ICollection#IsSynchronized">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:NDesk.Options.OptionValueCollection.System#Collections#ICollection#SyncRoot">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:NDesk.Options.OptionValueCollection.System#Collections#IEnumerable#GetEnumerator">
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:NDesk.Options.OptionValueCollection.System#Collections#IList#Add(System.Object)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:NDesk.Options.OptionValueCollection.System#Collections#IList#Contains(System.Object)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:NDesk.Options.OptionValueCollection.System#Collections#IList#IndexOf(System.Object)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:NDesk.Options.OptionValueCollection.System#Collections#IList#Insert(System.Int32,System.Object)">
            <param name="index">To be added.</param>
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:NDesk.Options.OptionValueCollection.System#Collections#IList#IsFixedSize">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:NDesk.Options.OptionValueCollection.System#Collections#IList#Item(System.Int32)">
            <param name="index">To be added.</param>
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:NDesk.Options.OptionValueCollection.System#Collections#IList#Remove(System.Object)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:NDesk.Options.OptionValueCollection.System#Collections#IList#RemoveAt(System.Int32)">
            <param name="index">To be added.</param>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:NDesk.Options.OptionValueCollection.ToArray">
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:NDesk.Options.OptionValueCollection.ToList">
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:NDesk.Options.OptionValueCollection.ToString">
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="T:NDesk.Options.OptionValueType">
            <summary>
      Specifies whether or not a <see cref="T:NDesk.Options.Option" />
      takes a value, and if it does, whether it's optional or required.
		</summary>
            <remarks />
            <altmember cref="P:NDesk.Options.Option.OptionValueType" />
        </member>
        <member name="F:NDesk.Options.OptionValueType.None">
            <summary>
                <para>No value is taken.</para>
                <para>If an option takes no value, then the callback function will 
          receive <see langword="null" /> if the value is 
          <see langword="false" /> (e.g. <c>-optionName-</c> was used) and 
          non-<see langword="null" /> if the value is <see langword="true" /> 
          (e.g. <c>-optionName</c>, <c>-optionName+</c>).</para>
            </summary>
        </member>
        <member name="F:NDesk.Options.OptionValueType.Optional">
            <summary>
                <para>A value is optional.</para>
                <para>This is specified by providing <c>:</c> after the option name
            within <see cref="P:NDesk.Options.Option.Prototype" />.</para>
                <para>If a value is optional, the callback function will receive
            <see langword="null" /> value if no value is provided, and will 
            otherwise receive a non-<see langword="null" /> value.</para>
                <para>Options with optional values are not "greedy" -- the value 
            must be part of the current argument, e.g. <c>-opt:foo</c> will 
            pass <c>"foo"</c> as the value to <c>-opt</c>, but <c>-opt foo</c> 
            will pass <see langword="null" /> as the value to <c>-opt</c>.
            </para>
            </summary>
        </member>
        <member name="F:NDesk.Options.OptionValueType.Required">
            <summary>
                <para>A value is required.</para>
                <para>This is specified by providing <c>=</c> after the option name
            within <see cref="P:NDesk.Options.Option.Prototype" />.</para>
                <para>Options with required values are "greedy" -- if the current
            argument does not contain a value, the next argument will be used
            as the value, e.g. both <c>-opt:foo</c> and <c>-opt foo</c> will
            pass <c>"foo"</c> as the value to <c>-opt</c>.</para>
            </summary>
        </member>
    </members>
</doc>
